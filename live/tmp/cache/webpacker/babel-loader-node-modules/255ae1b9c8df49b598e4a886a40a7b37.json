{"ast":null,"code":"function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction e(e) {\n  var t = \"==\".slice(0, (4 - e.length % 4) % 4),\n      n = e.replace(/-/g, \"+\").replace(/_/g, \"/\") + t,\n      r = atob(n),\n      o = new ArrayBuffer(r.length),\n      c = new Uint8Array(o);\n\n  for (var _e = 0; _e < r.length; _e++) {\n    c[_e] = r.charCodeAt(_e);\n  }\n\n  return o;\n}\n\nfunction t(e) {\n  var t = new Uint8Array(e);\n  var n = \"\";\n\n  for (var _iterator = _createForOfIteratorHelperLoose(t), _step; !(_step = _iterator()).done;) {\n    var _e2 = _step.value;\n    n += String.fromCharCode(_e2);\n  }\n\n  return btoa(n).replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=/g, \"\");\n}\n\nfunction n(e, t, r) {\n  if (\"copy\" === t) return r;\n  if (\"convert\" === t) return e(r);\n  if (t instanceof Array) return r.map(function (r) {\n    return n(e, t[0], r);\n  });\n\n  if (t instanceof Object) {\n    var _o = {};\n\n    for (var _i = 0, _Object$entries = Object.entries(t); _i < _Object$entries.length; _i++) {\n      var _Object$entries$_i = _Object$entries[_i],\n          _c = _Object$entries$_i[0],\n          _i2 = _Object$entries$_i[1];\n      if (_c in r) null != r[_c] ? _o[_c] = n(e, _i2.schema, r[_c]) : _o[_c] = null;else if (_i2.required) throw new Error(\"Missing key: \" + _c);\n    }\n\n    return _o;\n  }\n}\n\nfunction r(e) {\n  return {\n    required: !0,\n    schema: e\n  };\n}\n\nfunction o(e) {\n  return {\n    required: !1,\n    schema: e\n  };\n}\n\nvar c = {\n  type: r(\"copy\"),\n  id: r(\"convert\"),\n  transports: o(\"copy\")\n},\n    i = {\n  appid: o(\"copy\"),\n  appidExclude: o(\"copy\"),\n  credProps: o(\"copy\")\n},\n    a = {\n  appid: o(\"copy\"),\n  appidExclude: o(\"copy\"),\n  credProps: o(\"copy\")\n},\n    s = {\n  publicKey: r({\n    rp: r(\"copy\"),\n    user: r({\n      id: r(\"convert\"),\n      name: r(\"copy\"),\n      displayName: r(\"copy\")\n    }),\n    challenge: r(\"convert\"),\n    pubKeyCredParams: r(\"copy\"),\n    timeout: o(\"copy\"),\n    excludeCredentials: o([c]),\n    authenticatorSelection: o(\"copy\"),\n    attestation: o(\"copy\"),\n    extensions: o(i)\n  }),\n  signal: o(\"copy\")\n},\n    p = {\n  type: r(\"copy\"),\n  id: r(\"copy\"),\n  rawId: r(\"convert\"),\n  response: r({\n    clientDataJSON: r(\"convert\"),\n    attestationObject: r(\"convert\")\n  }),\n  clientExtensionResults: r(a)\n},\n    l = {\n  mediation: o(\"copy\"),\n  publicKey: r({\n    challenge: r(\"convert\"),\n    timeout: o(\"copy\"),\n    rpId: o(\"copy\"),\n    allowCredentials: o([c]),\n    userVerification: o(\"copy\"),\n    extensions: o(i)\n  }),\n  signal: o(\"copy\")\n},\n    u = {\n  type: r(\"copy\"),\n  id: r(\"copy\"),\n  rawId: r(\"convert\"),\n  response: r({\n    clientDataJSON: r(\"convert\"),\n    authenticatorData: r(\"convert\"),\n    signature: r(\"convert\"),\n    userHandle: r(\"convert\")\n  }),\n  clientExtensionResults: r(a)\n};\nexport var schema = {\n  credentialCreationOptions: s,\n  publicKeyCredentialWithAttestation: p,\n  credentialRequestOptions: l,\n  publicKeyCredentialWithAssertion: u\n};\nexport function create(_x) {\n  return _create.apply(this, arguments);\n}\n\nfunction _create() {\n  _create = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(r) {\n    return regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.t0 = function (e) {\n              var r = e;\n              return r.clientExtensionResults = e.getClientExtensionResults(), n(t, p, r);\n            };\n\n            _context.next = 3;\n            return navigator.credentials.create(function (t) {\n              return n(e, s, t);\n            }(r));\n\n          case 3:\n            _context.t1 = _context.sent;\n            return _context.abrupt(\"return\", (0, _context.t0)(_context.t1));\n\n          case 5:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _create.apply(this, arguments);\n}\n\nexport function get(_x2) {\n  return _get.apply(this, arguments);\n}\n\nfunction _get() {\n  _get = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(r) {\n    return regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.t0 = function (e) {\n              var r = e;\n              return r.clientExtensionResults = e.getClientExtensionResults(), n(t, u, r);\n            };\n\n            _context2.next = 3;\n            return navigator.credentials.get(function (t) {\n              return n(e, l, t);\n            }(r));\n\n          case 3:\n            _context2.t1 = _context2.sent;\n            return _context2.abrupt(\"return\", (0, _context2.t0)(_context2.t1));\n\n          case 5:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _get.apply(this, arguments);\n}\n\nexport function supported() {\n  return !!(navigator.credentials && navigator.credentials.create && navigator.credentials.get && window.PublicKeyCredential);\n}","map":null,"metadata":{"react-intl":{"messages":[]}},"sourceType":"module"}