{"ast":null,"code":"import api from '../api';\nimport { debounce } from 'lodash';\nimport compareId from '../compare_id';\nexport var MARKERS_FETCH_REQUEST = 'MARKERS_FETCH_REQUEST';\nexport var MARKERS_FETCH_SUCCESS = 'MARKERS_FETCH_SUCCESS';\nexport var MARKERS_FETCH_FAIL = 'MARKERS_FETCH_FAIL';\nexport var MARKERS_SUBMIT_SUCCESS = 'MARKERS_SUBMIT_SUCCESS';\nexport var synchronouslySubmitMarkers = function synchronouslySubmitMarkers() {\n  return function (dispatch, getState) {\n    var accessToken = getState().getIn(['meta', 'access_token'], '');\n\n    var params = _buildParams(getState());\n\n    if (Object.keys(params).length === 0) {\n      return;\n    } // The Fetch API allows us to perform requests that will be carried out\n    // after the page closes. But that only works if the `keepalive` attribute\n    // is supported.\n\n\n    if (window.fetch && 'keepalive' in new Request('')) {\n      fetch('/api/v1/markers', {\n        keepalive: true,\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': \"Bearer \" + accessToken\n        },\n        body: JSON.stringify(params)\n      });\n      return;\n    } else if (navigator && navigator.sendBeacon) {\n      // Failing that, we can use sendBeacon, but we have to encode the data as\n      // FormData for DoorKeeper to recognize the token.\n      var formData = new FormData();\n      formData.append('bearer_token', accessToken);\n\n      for (var _i = 0, _Object$entries = Object.entries(params); _i < _Object$entries.length; _i++) {\n        var _Object$entries$_i = _Object$entries[_i],\n            id = _Object$entries$_i[0],\n            value = _Object$entries$_i[1];\n        formData.append(id + \"[last_read_id]\", value.last_read_id);\n      }\n\n      if (navigator.sendBeacon('/api/v1/markers', formData)) {\n        return;\n      }\n    } // If neither Fetch nor sendBeacon worked, try to perform a synchronous\n    // request.\n\n\n    try {\n      var client = new XMLHttpRequest();\n      client.open('POST', '/api/v1/markers', false);\n      client.setRequestHeader('Content-Type', 'application/json');\n      client.setRequestHeader('Authorization', \"Bearer \" + accessToken);\n      client.SUBMIT(JSON.stringify(params));\n    } catch (e) {// Do not make the BeforeUnload handler error out\n    }\n  };\n};\n\nvar _buildParams = function _buildParams(state) {\n  var params = {};\n  var lastHomeId = state.getIn(['timelines', 'home', 'items']).find(function (item) {\n    return item !== null;\n  });\n  var lastNotificationId = state.getIn(['notifications', 'lastReadId']);\n\n  if (lastHomeId && compareId(lastHomeId, state.getIn(['markers', 'home'])) > 0) {\n    params.home = {\n      last_read_id: lastHomeId\n    };\n  }\n\n  if (lastNotificationId && compareId(lastNotificationId, state.getIn(['markers', 'notifications'])) > 0) {\n    params.notifications = {\n      last_read_id: lastNotificationId\n    };\n  }\n\n  return params;\n};\n\nvar debouncedSubmitMarkers = debounce(function (dispatch, getState) {\n  var params = _buildParams(getState());\n\n  if (Object.keys(params).length === 0) {\n    return;\n  }\n\n  api(getState).post('/api/v1/markers', params).then(function () {\n    dispatch(submitMarkersSuccess(params));\n  }).catch(function () {});\n}, 300000, {\n  leading: true,\n  trailing: true\n});\nexport function submitMarkersSuccess(_ref) {\n  var home = _ref.home,\n      notifications = _ref.notifications;\n  return {\n    type: MARKERS_SUBMIT_SUCCESS,\n    home: (home || {}).last_read_id,\n    notifications: (notifications || {}).last_read_id\n  };\n}\n;\nexport function submitMarkers(params) {\n  if (params === void 0) {\n    params = {};\n  }\n\n  var result = function result(dispatch, getState) {\n    return debouncedSubmitMarkers(dispatch, getState);\n  };\n\n  if (params.immediate === true) {\n    debouncedSubmitMarkers.flush();\n  }\n\n  return result;\n}\n;\nexport var fetchMarkers = function fetchMarkers() {\n  return function (dispatch, getState) {\n    var params = {\n      timeline: ['notifications']\n    };\n    dispatch(fetchMarkersRequest());\n    api(getState).get('/api/v1/markers', {\n      params\n    }).then(function (response) {\n      dispatch(fetchMarkersSuccess(response.data));\n    }).catch(function (error) {\n      dispatch(fetchMarkersFail(error));\n    });\n  };\n};\nexport function fetchMarkersRequest() {\n  return {\n    type: MARKERS_FETCH_REQUEST,\n    skipLoading: true\n  };\n}\n;\nexport function fetchMarkersSuccess(markers) {\n  return {\n    type: MARKERS_FETCH_SUCCESS,\n    markers,\n    skipLoading: true\n  };\n}\n;\nexport function fetchMarkersFail(error) {\n  return {\n    type: MARKERS_FETCH_FAIL,\n    error,\n    skipLoading: true,\n    skipAlert: true\n  };\n}\n;","map":{"version":3,"sources":["/home/runner/Mastodon/live/app/javascript/mastodon/actions/markers.js"],"names":["api","debounce","compareId","MARKERS_FETCH_REQUEST","MARKERS_FETCH_SUCCESS","MARKERS_FETCH_FAIL","MARKERS_SUBMIT_SUCCESS","synchronouslySubmitMarkers","dispatch","getState","accessToken","getIn","params","_buildParams","Object","keys","length","window","fetch","Request","keepalive","method","headers","body","JSON","stringify","navigator","sendBeacon","formData","FormData","append","entries","id","value","last_read_id","client","XMLHttpRequest","open","setRequestHeader","SUBMIT","e","state","lastHomeId","find","item","lastNotificationId","home","notifications","debouncedSubmitMarkers","post","then","submitMarkersSuccess","catch","leading","trailing","type","submitMarkers","result","immediate","flush","fetchMarkers","timeline","fetchMarkersRequest","get","response","fetchMarkersSuccess","data","error","fetchMarkersFail","skipLoading","markers","skipAlert"],"mappings":"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","sourcesContent":["import api from '../api';\nimport { debounce } from 'lodash';\nimport compareId from '../compare_id';\n\nexport const MARKERS_FETCH_REQUEST = 'MARKERS_FETCH_REQUEST';\nexport const MARKERS_FETCH_SUCCESS = 'MARKERS_FETCH_SUCCESS';\nexport const MARKERS_FETCH_FAIL    = 'MARKERS_FETCH_FAIL';\nexport const MARKERS_SUBMIT_SUCCESS = 'MARKERS_SUBMIT_SUCCESS';\n\nexport const synchronouslySubmitMarkers = () => (dispatch, getState) => {\n  const accessToken = getState().getIn(['meta', 'access_token'], '');\n  const params      = _buildParams(getState());\n\n  if (Object.keys(params).length === 0) {\n    return;\n  }\n\n  // The Fetch API allows us to perform requests that will be carried out\n  // after the page closes. But that only works if the `keepalive` attribute\n  // is supported.\n  if (window.fetch && 'keepalive' in new Request('')) {\n    fetch('/api/v1/markers', {\n      keepalive: true,\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'Authorization': `Bearer ${accessToken}`,\n      },\n      body: JSON.stringify(params),\n    });\n\n    return;\n  } else if (navigator && navigator.sendBeacon) {\n    // Failing that, we can use sendBeacon, but we have to encode the data as\n    // FormData for DoorKeeper to recognize the token.\n    const formData = new FormData();\n\n    formData.append('bearer_token', accessToken);\n\n    for (const [id, value] of Object.entries(params)) {\n      formData.append(`${id}[last_read_id]`, value.last_read_id);\n    }\n\n    if (navigator.sendBeacon('/api/v1/markers', formData)) {\n      return;\n    }\n  }\n\n  // If neither Fetch nor sendBeacon worked, try to perform a synchronous\n  // request.\n  try {\n    const client = new XMLHttpRequest();\n\n    client.open('POST', '/api/v1/markers', false);\n    client.setRequestHeader('Content-Type', 'application/json');\n    client.setRequestHeader('Authorization', `Bearer ${accessToken}`);\n    client.SUBMIT(JSON.stringify(params));\n  } catch (e) {\n    // Do not make the BeforeUnload handler error out\n  }\n};\n\nconst _buildParams = (state) => {\n  const params = {};\n\n  const lastHomeId         = state.getIn(['timelines', 'home', 'items']).find(item => item !== null);\n  const lastNotificationId = state.getIn(['notifications', 'lastReadId']);\n\n  if (lastHomeId && compareId(lastHomeId, state.getIn(['markers', 'home'])) > 0) {\n    params.home = {\n      last_read_id: lastHomeId,\n    };\n  }\n\n  if (lastNotificationId && compareId(lastNotificationId, state.getIn(['markers', 'notifications'])) > 0) {\n    params.notifications = {\n      last_read_id: lastNotificationId,\n    };\n  }\n\n  return params;\n};\n\nconst debouncedSubmitMarkers = debounce((dispatch, getState) => {\n  const params = _buildParams(getState());\n\n  if (Object.keys(params).length === 0) {\n    return;\n  }\n\n  api(getState).post('/api/v1/markers', params).then(() => {\n    dispatch(submitMarkersSuccess(params));\n  }).catch(() => {});\n}, 300000, { leading: true, trailing: true });\n\nexport function submitMarkersSuccess({ home, notifications }) {\n  return {\n    type: MARKERS_SUBMIT_SUCCESS,\n    home: (home || {}).last_read_id,\n    notifications: (notifications || {}).last_read_id,\n  };\n};\n\nexport function submitMarkers(params = {}) {\n  const result = (dispatch, getState) => debouncedSubmitMarkers(dispatch, getState);\n\n  if (params.immediate === true) {\n    debouncedSubmitMarkers.flush();\n  }\n\n  return result;\n};\n\nexport const fetchMarkers = () => (dispatch, getState) => {\n  const params = { timeline: ['notifications'] };\n\n  dispatch(fetchMarkersRequest());\n\n  api(getState).get('/api/v1/markers', { params }).then(response => {\n    dispatch(fetchMarkersSuccess(response.data));\n  }).catch(error => {\n    dispatch(fetchMarkersFail(error));\n  });\n};\n\nexport function fetchMarkersRequest() {\n  return {\n    type: MARKERS_FETCH_REQUEST,\n    skipLoading: true,\n  };\n};\n\nexport function fetchMarkersSuccess(markers) {\n  return {\n    type: MARKERS_FETCH_SUCCESS,\n    markers,\n    skipLoading: true,\n  };\n};\n\nexport function fetchMarkersFail(error) {\n  return {\n    type: MARKERS_FETCH_FAIL,\n    error,\n    skipLoading: true,\n    skipAlert: true,\n  };\n};\n"]},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module"}