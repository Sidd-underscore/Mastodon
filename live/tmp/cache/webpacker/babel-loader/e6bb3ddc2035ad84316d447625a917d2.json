{"ast":null,"code":"import EXIF from 'exif-js';\nvar MAX_IMAGE_PIXELS = 2073600; // 1920x1080px\n\nvar _browser_quirks = {}; // Some browsers will automatically draw images respecting their EXIF orientation\n// while others won't, and the safest way to detect that is to examine how it\n// is done on a known image.\n// See https://github.com/w3c/csswg-drafts/issues/4666\n// and https://github.com/blueimp/JavaScript-Load-Image/commit/1e4df707821a0afcc11ea0720ee403b8759f3881\n\nvar dropOrientationIfNeeded = function dropOrientationIfNeeded(orientation) {\n  return new Promise(function (resolve) {\n    switch (_browser_quirks['image-orientation-automatic']) {\n      case true:\n        resolve(1);\n        break;\n\n      case false:\n        resolve(orientation);\n        break;\n\n      default:\n        // black 2x1 JPEG, with the following meta information set:\n        // - EXIF Orientation: 6 (Rotated 90° CCW)\n        var testImageURL = 'data:image/jpeg;base64,/9j/4QAiRXhpZgAATU0AKgAAAAgAAQESAAMAAAABAAYAAAA' + 'AAAD/2wCEAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBA' + 'QEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQE' + 'BAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAf/AABEIAAEAAgMBEQACEQEDEQH/x' + 'ABKAAEAAAAAAAAAAAAAAAAAAAALEAEAAAAAAAAAAAAAAAAAAAAAAQEAAAAAAAAAAAAAAAA' + 'AAAAAEQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIRAxEAPwA/8H//2Q==';\n        var img = new Image();\n\n        img.onload = function () {\n          var automatic = img.width === 1 && img.height === 2;\n          _browser_quirks['image-orientation-automatic'] = automatic;\n          resolve(automatic ? 1 : orientation);\n        };\n\n        img.onerror = function () {\n          _browser_quirks['image-orientation-automatic'] = false;\n          resolve(orientation);\n        };\n\n        img.src = testImageURL;\n    }\n  });\n}; // Some browsers don't allow reading from a canvas and instead return all-white\n// or randomized data. Use a pre-defined image to check if reading the canvas\n// works.\n\n\nvar checkCanvasReliability = function checkCanvasReliability() {\n  return new Promise(function (resolve, reject) {\n    switch (_browser_quirks['canvas-read-unreliable']) {\n      case true:\n        reject('Canvas reading unreliable');\n        break;\n\n      case false:\n        resolve();\n        break;\n\n      default:\n        // 2×2 GIF with white, red, green and blue pixels\n        var testImageURL = 'data:image/gif;base64,R0lGODdhAgACAKEDAAAA//8AAAD/AP///ywAAAAAAgACAAACA1wEBQA7';\n        var refData = [255, 255, 255, 255, 255, 0, 0, 255, 0, 255, 0, 255, 0, 0, 255, 255];\n        var img = new Image();\n\n        img.onload = function () {\n          var canvas = document.createElement('canvas');\n          var context = canvas.getContext('2d');\n          context.drawImage(img, 0, 0, 2, 2);\n          var imageData = context.getImageData(0, 0, 2, 2);\n\n          if (imageData.data.every(function (x, i) {\n            return refData[i] === x;\n          })) {\n            _browser_quirks['canvas-read-unreliable'] = false;\n            resolve();\n          } else {\n            _browser_quirks['canvas-read-unreliable'] = true;\n            reject('Canvas reading unreliable');\n          }\n        };\n\n        img.onerror = function () {\n          _browser_quirks['canvas-read-unreliable'] = true;\n          reject('Failed to load test image');\n        };\n\n        img.src = testImageURL;\n    }\n  });\n};\n\nvar getImageUrl = function getImageUrl(inputFile) {\n  return new Promise(function (resolve, reject) {\n    if (window.URL && URL.createObjectURL) {\n      try {\n        resolve(URL.createObjectURL(inputFile));\n      } catch (error) {\n        reject(error);\n      }\n\n      return;\n    }\n\n    var reader = new FileReader();\n\n    reader.onerror = function () {\n      return reject.apply(void 0, arguments);\n    };\n\n    reader.onload = function (_ref) {\n      var target = _ref.target;\n      return resolve(target.result);\n    };\n\n    reader.readAsDataURL(inputFile);\n  });\n};\n\nvar loadImage = function loadImage(inputFile) {\n  return new Promise(function (resolve, reject) {\n    getImageUrl(inputFile).then(function (url) {\n      var img = new Image();\n\n      img.onerror = function () {\n        return reject.apply(void 0, arguments);\n      };\n\n      img.onload = function () {\n        return resolve(img);\n      };\n\n      img.src = url;\n    }).catch(reject);\n  });\n};\n\nvar getOrientation = function getOrientation(img, type) {\n  if (type === void 0) {\n    type = 'image/png';\n  }\n\n  return new Promise(function (resolve) {\n    if (type !== 'image/jpeg') {\n      resolve(1);\n      return;\n    }\n\n    EXIF.getData(img, function () {\n      var orientation = EXIF.getTag(img, 'Orientation');\n\n      if (orientation !== 1) {\n        dropOrientationIfNeeded(orientation).then(resolve).catch(function () {\n          return resolve(orientation);\n        });\n      } else {\n        resolve(orientation);\n      }\n    });\n  });\n};\n\nvar processImage = function processImage(img, _ref2) {\n  var width = _ref2.width,\n      height = _ref2.height,\n      orientation = _ref2.orientation,\n      _ref2$type = _ref2.type,\n      type = _ref2$type === void 0 ? 'image/png' : _ref2$type;\n  return new Promise(function (resolve) {\n    var canvas = document.createElement('canvas');\n\n    if (4 < orientation && orientation < 9) {\n      canvas.width = height;\n      canvas.height = width;\n    } else {\n      canvas.width = width;\n      canvas.height = height;\n    }\n\n    var context = canvas.getContext('2d');\n\n    switch (orientation) {\n      case 2:\n        context.transform(-1, 0, 0, 1, width, 0);\n        break;\n\n      case 3:\n        context.transform(-1, 0, 0, -1, width, height);\n        break;\n\n      case 4:\n        context.transform(1, 0, 0, -1, 0, height);\n        break;\n\n      case 5:\n        context.transform(0, 1, 1, 0, 0, 0);\n        break;\n\n      case 6:\n        context.transform(0, 1, -1, 0, height, 0);\n        break;\n\n      case 7:\n        context.transform(0, -1, -1, 0, height, width);\n        break;\n\n      case 8:\n        context.transform(0, -1, 1, 0, 0, width);\n        break;\n    }\n\n    context.drawImage(img, 0, 0, width, height);\n    canvas.toBlob(resolve, type);\n  });\n};\n\nvar resizeImage = function resizeImage(img, type) {\n  if (type === void 0) {\n    type = 'image/png';\n  }\n\n  return new Promise(function (resolve, reject) {\n    var width = img.width,\n        height = img.height;\n    var newWidth = Math.round(Math.sqrt(MAX_IMAGE_PIXELS * (width / height)));\n    var newHeight = Math.round(Math.sqrt(MAX_IMAGE_PIXELS * (height / width)));\n    checkCanvasReliability().then(getOrientation(img, type)).then(function (orientation) {\n      return processImage(img, {\n        width: newWidth,\n        height: newHeight,\n        orientation,\n        type\n      });\n    }).then(resolve).catch(reject);\n  });\n};\n\nexport default (function (inputFile) {\n  return new Promise(function (resolve) {\n    if (!inputFile.type.match(/image.*/) || inputFile.type === 'image/gif') {\n      resolve(inputFile);\n      return;\n    }\n\n    loadImage(inputFile).then(function (img) {\n      if (img.width * img.height < MAX_IMAGE_PIXELS) {\n        resolve(inputFile);\n        return;\n      }\n\n      resizeImage(img, inputFile.type).then(resolve).catch(function () {\n        return resolve(inputFile);\n      });\n    }).catch(function () {\n      return resolve(inputFile);\n    });\n  });\n});","map":{"version":3,"sources":["/home/runner/Mastodon/live/app/javascript/mastodon/utils/resize_image.js"],"names":["EXIF","MAX_IMAGE_PIXELS","_browser_quirks","dropOrientationIfNeeded","orientation","Promise","resolve","testImageURL","img","Image","onload","automatic","width","height","onerror","src","checkCanvasReliability","reject","refData","canvas","document","createElement","context","getContext","drawImage","imageData","getImageData","data","every","x","i","getImageUrl","inputFile","window","URL","createObjectURL","error","reader","FileReader","target","result","readAsDataURL","loadImage","then","url","catch","getOrientation","type","getData","getTag","processImage","transform","toBlob","resizeImage","newWidth","Math","round","sqrt","newHeight","match"],"mappings":"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","sourcesContent":["import EXIF from 'exif-js';\n\nconst MAX_IMAGE_PIXELS = 2073600; // 1920x1080px\n\nconst _browser_quirks = {};\n\n// Some browsers will automatically draw images respecting their EXIF orientation\n// while others won't, and the safest way to detect that is to examine how it\n// is done on a known image.\n// See https://github.com/w3c/csswg-drafts/issues/4666\n// and https://github.com/blueimp/JavaScript-Load-Image/commit/1e4df707821a0afcc11ea0720ee403b8759f3881\nconst dropOrientationIfNeeded = (orientation) => new Promise(resolve => {\n  switch (_browser_quirks['image-orientation-automatic']) {\n  case true:\n    resolve(1);\n    break;\n  case false:\n    resolve(orientation);\n    break;\n  default:\n    // black 2x1 JPEG, with the following meta information set:\n    // - EXIF Orientation: 6 (Rotated 90° CCW)\n    const testImageURL =\n      'data:image/jpeg;base64,/9j/4QAiRXhpZgAATU0AKgAAAAgAAQESAAMAAAABAAYAAAA' +\n      'AAAD/2wCEAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBA' +\n      'QEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQE' +\n      'BAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAf/AABEIAAEAAgMBEQACEQEDEQH/x' +\n      'ABKAAEAAAAAAAAAAAAAAAAAAAALEAEAAAAAAAAAAAAAAAAAAAAAAQEAAAAAAAAAAAAAAAA' +\n      'AAAAAEQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIRAxEAPwA/8H//2Q==';\n    const img = new Image();\n    img.onload = () => {\n      const automatic = (img.width === 1 && img.height === 2);\n      _browser_quirks['image-orientation-automatic'] = automatic;\n      resolve(automatic ? 1 : orientation);\n    };\n    img.onerror = () => {\n      _browser_quirks['image-orientation-automatic'] = false;\n      resolve(orientation);\n    };\n    img.src = testImageURL;\n  }\n});\n\n// Some browsers don't allow reading from a canvas and instead return all-white\n// or randomized data. Use a pre-defined image to check if reading the canvas\n// works.\nconst checkCanvasReliability = () => new Promise((resolve, reject) => {\n  switch(_browser_quirks['canvas-read-unreliable']) {\n  case true:\n    reject('Canvas reading unreliable');\n    break;\n  case false:\n    resolve();\n    break;\n  default:\n    // 2×2 GIF with white, red, green and blue pixels\n    const testImageURL =\n      'data:image/gif;base64,R0lGODdhAgACAKEDAAAA//8AAAD/AP///ywAAAAAAgACAAACA1wEBQA7';\n    const refData =\n      [255, 255, 255, 255,  255, 0, 0, 255,  0, 255, 0, 255,  0, 0, 255, 255];\n    const img = new Image();\n    img.onload = () => {\n      const canvas  = document.createElement('canvas');\n      const context = canvas.getContext('2d');\n      context.drawImage(img, 0, 0, 2, 2);\n      const imageData = context.getImageData(0, 0, 2, 2);\n      if (imageData.data.every((x, i) => refData[i] === x)) {\n        _browser_quirks['canvas-read-unreliable'] = false;\n        resolve();\n      } else {\n        _browser_quirks['canvas-read-unreliable'] = true;\n        reject('Canvas reading unreliable');\n      }\n    };\n    img.onerror = () => {\n      _browser_quirks['canvas-read-unreliable'] = true;\n      reject('Failed to load test image');\n    };\n    img.src = testImageURL;\n  }\n});\n\nconst getImageUrl = inputFile => new Promise((resolve, reject) => {\n  if (window.URL && URL.createObjectURL) {\n    try {\n      resolve(URL.createObjectURL(inputFile));\n    } catch (error) {\n      reject(error);\n    }\n    return;\n  }\n\n  const reader = new FileReader();\n  reader.onerror = (...args) => reject(...args);\n  reader.onload  = ({ target }) => resolve(target.result);\n\n  reader.readAsDataURL(inputFile);\n});\n\nconst loadImage = inputFile => new Promise((resolve, reject) => {\n  getImageUrl(inputFile).then(url => {\n    const img = new Image();\n\n    img.onerror = (...args) => reject(...args);\n    img.onload  = () => resolve(img);\n\n    img.src = url;\n  }).catch(reject);\n});\n\nconst getOrientation = (img, type = 'image/png') => new Promise(resolve => {\n  if (type !== 'image/jpeg') {\n    resolve(1);\n    return;\n  }\n\n  EXIF.getData(img, () => {\n    const orientation = EXIF.getTag(img, 'Orientation');\n    if (orientation !== 1) {\n      dropOrientationIfNeeded(orientation).then(resolve).catch(() => resolve(orientation));\n    } else {\n      resolve(orientation);\n    }\n  });\n});\n\nconst processImage = (img, { width, height, orientation, type = 'image/png' }) => new Promise(resolve => {\n  const canvas  = document.createElement('canvas');\n\n  if (4 < orientation && orientation < 9) {\n    canvas.width  = height;\n    canvas.height = width;\n  } else {\n    canvas.width  = width;\n    canvas.height = height;\n  }\n\n  const context = canvas.getContext('2d');\n\n  switch (orientation) {\n  case 2: context.transform(-1, 0, 0, 1, width, 0); break;\n  case 3: context.transform(-1, 0, 0, -1, width, height); break;\n  case 4: context.transform(1, 0, 0, -1, 0, height); break;\n  case 5: context.transform(0, 1, 1, 0, 0, 0); break;\n  case 6: context.transform(0, 1, -1, 0, height, 0); break;\n  case 7: context.transform(0, -1, -1, 0, height, width); break;\n  case 8: context.transform(0, -1, 1, 0, 0, width); break;\n  }\n\n  context.drawImage(img, 0, 0, width, height);\n\n  canvas.toBlob(resolve, type);\n});\n\nconst resizeImage = (img, type = 'image/png') => new Promise((resolve, reject) => {\n  const { width, height } = img;\n\n  const newWidth  = Math.round(Math.sqrt(MAX_IMAGE_PIXELS * (width / height)));\n  const newHeight = Math.round(Math.sqrt(MAX_IMAGE_PIXELS * (height / width)));\n\n  checkCanvasReliability()\n    .then(getOrientation(img, type))\n    .then(orientation => processImage(img, {\n      width: newWidth,\n      height: newHeight,\n      orientation,\n      type,\n    }))\n    .then(resolve)\n    .catch(reject);\n});\n\nexport default inputFile => new Promise((resolve) => {\n  if (!inputFile.type.match(/image.*/) || inputFile.type === 'image/gif') {\n    resolve(inputFile);\n    return;\n  }\n\n  loadImage(inputFile).then(img => {\n    if (img.width * img.height < MAX_IMAGE_PIXELS) {\n      resolve(inputFile);\n      return;\n    }\n\n    resizeImage(img, inputFile.type)\n      .then(resolve)\n      .catch(() => resolve(inputFile));\n  }).catch(() => resolve(inputFile));\n});\n"]},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module"}