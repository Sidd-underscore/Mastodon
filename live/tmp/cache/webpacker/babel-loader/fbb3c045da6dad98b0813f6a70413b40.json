{"ast":null,"code":"var _excluded = [\"hash\", \"width\", \"height\", \"dummy\"];\nvar _jsxFileName = \"/home/runner/Mastodon/live/app/javascript/mastodon/components/blurhash.js\";\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n// @ts-check\nimport { decode } from 'blurhash';\nimport React, { useRef, useEffect } from 'react';\nimport PropTypes from 'prop-types';\n/**\n * @typedef BlurhashPropsBase\n * @property {string?} hash Hash to render\n * @property {number} width\n * Width of the blurred region in pixels. Defaults to 32\n * @property {number} [height]\n * Height of the blurred region in pixels. Defaults to width\n * @property {boolean} [dummy]\n * Whether dummy mode is enabled. If enabled, nothing is rendered\n * and canvas left untouched\n */\n\n/** @typedef {JSX.IntrinsicElements['canvas'] & BlurhashPropsBase} BlurhashProps */\n\n/**\n * Component that is used to render blurred of blurhash string\n *\n * @param {BlurhashProps} param1 Props of the component\n * @returns Canvas which will render blurred region element to embed\n */\n\nfunction Blurhash(_ref) {\n  var hash = _ref.hash,\n      _ref$width = _ref.width,\n      width = _ref$width === void 0 ? 32 : _ref$width,\n      _ref$height = _ref.height,\n      height = _ref$height === void 0 ? width : _ref$height,\n      _ref$dummy = _ref.dummy,\n      dummy = _ref$dummy === void 0 ? false : _ref$dummy,\n      canvasProps = _objectWithoutPropertiesLoose(_ref, _excluded);\n\n  var canvasRef =\n  /** @type {import('react').MutableRefObject<HTMLCanvasElement>} */\n  useRef();\n  useEffect(function () {\n    var canvas = canvasRef.current;\n    canvas.width = canvas.width; // resets canvas\n\n    if (dummy || !hash) return;\n\n    try {\n      var pixels = decode(hash, width, height);\n      var ctx = canvas.getContext('2d');\n      var imageData = new ImageData(pixels, width, height);\n      ctx.putImageData(imageData, 0, 0);\n    } catch (err) {\n      console.error('Blurhash decoding failure', {\n        err,\n        hash\n      });\n    }\n  }, [dummy, hash, width, height]);\n  return /*#__PURE__*/React.createElement(\"canvas\", _extends({}, canvasProps, {\n    ref: canvasRef,\n    width: width,\n    height: height,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 54,\n      columnNumber: 5\n    }\n  }));\n}\n\nBlurhash.propTypes = {\n  hash: PropTypes.string.isRequired,\n  width: PropTypes.number,\n  height: PropTypes.number,\n  dummy: PropTypes.bool\n};\nexport default /*#__PURE__*/React.memo(Blurhash);","map":{"version":3,"sources":["/home/runner/Mastodon/live/app/javascript/mastodon/components/blurhash.js"],"names":["decode","React","useRef","useEffect","PropTypes","Blurhash","hash","width","height","dummy","canvasProps","canvasRef","canvas","current","pixels","ctx","getContext","imageData","ImageData","putImageData","err","console","error","propTypes","string","isRequired","number","bool","memo"],"mappings":";;;;;;;AAAA;AAEA,SAASA,MAAT,QAAuB,UAAvB;AACA,OAAOC,KAAP,IAAgBC,MAAhB,EAAwBC,SAAxB,QAAyC,OAAzC;AACA,OAAOC,SAAP,MAAsB,YAAtB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASC,QAAT,OAMG;AAAA,MALDC,IAKC,QALDA,IAKC;AAAA,wBAJDC,KAIC;AAAA,MAJDA,KAIC,2BAJO,EAIP;AAAA,yBAHDC,MAGC;AAAA,MAHDA,MAGC,4BAHQD,KAGR;AAAA,wBAFDE,KAEC;AAAA,MAFDA,KAEC,2BAFO,KAEP;AAAA,MADEC,WACF;;AACD,MAAMC,SAAS;AAAG;AAAoET,EAAAA,MAAM,EAA5F;AAEAC,EAAAA,SAAS,CAAC,YAAM;AACd,QAAiBS,MAAjB,GAA4BD,SAA5B,CAAQE,OAAR;AACAD,IAAAA,MAAM,CAACL,KAAP,GAAeK,MAAM,CAACL,KAAtB,CAFc,CAEe;;AAE7B,QAAIE,KAAK,IAAI,CAACH,IAAd,EAAoB;;AAEpB,QAAI;AACF,UAAMQ,MAAM,GAAGd,MAAM,CAACM,IAAD,EAAOC,KAAP,EAAcC,MAAd,CAArB;AACA,UAAMO,GAAG,GAAGH,MAAM,CAACI,UAAP,CAAkB,IAAlB,CAAZ;AACA,UAAMC,SAAS,GAAG,IAAIC,SAAJ,CAAcJ,MAAd,EAAsBP,KAAtB,EAA6BC,MAA7B,CAAlB;AAEAO,MAAAA,GAAG,CAACI,YAAJ,CAAiBF,SAAjB,EAA4B,CAA5B,EAA+B,CAA/B;AACD,KAND,CAME,OAAOG,GAAP,EAAY;AACZC,MAAAA,OAAO,CAACC,KAAR,CAAc,2BAAd,EAA2C;AAAEF,QAAAA,GAAF;AAAOd,QAAAA;AAAP,OAA3C;AACD;AACF,GAfQ,EAeN,CAACG,KAAD,EAAQH,IAAR,EAAcC,KAAd,EAAqBC,MAArB,CAfM,CAAT;AAiBA,sBACE,2CAAYE,WAAZ;AAAyB,IAAA,GAAG,EAAEC,SAA9B;AAAyC,IAAA,KAAK,EAAEJ,KAAhD;AAAuD,IAAA,MAAM,EAAEC,MAA/D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KADF;AAGD;;AAEDH,QAAQ,CAACkB,SAAT,GAAqB;AACnBjB,EAAAA,IAAI,EAAEF,SAAS,CAACoB,MAAV,CAAiBC,UADJ;AAEnBlB,EAAAA,KAAK,EAAEH,SAAS,CAACsB,MAFE;AAGnBlB,EAAAA,MAAM,EAAEJ,SAAS,CAACsB,MAHC;AAInBjB,EAAAA,KAAK,EAAEL,SAAS,CAACuB;AAJE,CAArB;AAOA,4BAAe1B,KAAK,CAAC2B,IAAN,CAAWvB,QAAX,CAAf","sourcesContent":["// @ts-check\n\nimport { decode } from 'blurhash';\nimport React, { useRef, useEffect } from 'react';\nimport PropTypes from 'prop-types';\n\n/**\n * @typedef BlurhashPropsBase\n * @property {string?} hash Hash to render\n * @property {number} width\n * Width of the blurred region in pixels. Defaults to 32\n * @property {number} [height]\n * Height of the blurred region in pixels. Defaults to width\n * @property {boolean} [dummy]\n * Whether dummy mode is enabled. If enabled, nothing is rendered\n * and canvas left untouched\n */\n\n/** @typedef {JSX.IntrinsicElements['canvas'] & BlurhashPropsBase} BlurhashProps */\n\n/**\n * Component that is used to render blurred of blurhash string\n *\n * @param {BlurhashProps} param1 Props of the component\n * @returns Canvas which will render blurred region element to embed\n */\nfunction Blurhash({\n  hash,\n  width = 32,\n  height = width,\n  dummy = false,\n  ...canvasProps\n}) {\n  const canvasRef = /** @type {import('react').MutableRefObject<HTMLCanvasElement>} */ (useRef());\n\n  useEffect(() => {\n    const { current: canvas } = canvasRef;\n    canvas.width = canvas.width; // resets canvas\n\n    if (dummy || !hash) return;\n\n    try {\n      const pixels = decode(hash, width, height);\n      const ctx = canvas.getContext('2d');\n      const imageData = new ImageData(pixels, width, height);\n\n      ctx.putImageData(imageData, 0, 0);\n    } catch (err) {\n      console.error('Blurhash decoding failure', { err, hash });\n    }\n  }, [dummy, hash, width, height]);\n\n  return (\n    <canvas {...canvasProps} ref={canvasRef} width={width} height={height} />\n  );\n}\n\nBlurhash.propTypes = {\n  hash: PropTypes.string.isRequired,\n  width: PropTypes.number,\n  height: PropTypes.number,\n  dummy: PropTypes.bool,\n};\n\nexport default React.memo(Blurhash);\n"]},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module"}