{"ast":null,"code":"// Wrapper for IntersectionObserver in order to make working with it\n// a bit easier. We also follow this performance advice:\n// \"If you need to observe multiple elements, it is both possible and\n// advised to observe multiple elements using the same IntersectionObserver\n// instance by calling observe() multiple times.\"\n// https://developers.google.com/web/updates/2016/04/intersectionobserver\nvar IntersectionObserverWrapper = /*#__PURE__*/function () {\n  function IntersectionObserverWrapper() {\n    this.callbacks = {};\n    this.observerBacklog = [];\n    this.observer = null;\n  }\n\n  var _proto = IntersectionObserverWrapper.prototype;\n\n  _proto.connect = function connect(options) {\n    var _this = this;\n\n    var onIntersection = function onIntersection(entries) {\n      entries.forEach(function (entry) {\n        var id = entry.target.getAttribute('data-id');\n\n        if (_this.callbacks[id]) {\n          _this.callbacks[id](entry);\n        }\n      });\n    };\n\n    this.observer = new IntersectionObserver(onIntersection, options);\n    this.observerBacklog.forEach(function (_ref) {\n      var id = _ref[0],\n          node = _ref[1],\n          callback = _ref[2];\n\n      _this.observe(id, node, callback);\n    });\n    this.observerBacklog = null;\n  };\n\n  _proto.observe = function observe(id, node, callback) {\n    if (!this.observer) {\n      this.observerBacklog.push([id, node, callback]);\n    } else {\n      this.callbacks[id] = callback;\n      this.observer.observe(node);\n    }\n  };\n\n  _proto.unobserve = function unobserve(id, node) {\n    if (this.observer) {\n      delete this.callbacks[id];\n      this.observer.unobserve(node);\n    }\n  };\n\n  _proto.disconnect = function disconnect() {\n    if (this.observer) {\n      this.callbacks = {};\n      this.observer.disconnect();\n      this.observer = null;\n    }\n  };\n\n  return IntersectionObserverWrapper;\n}();\n\nexport default IntersectionObserverWrapper;","map":{"version":3,"sources":["/home/runner/Mastodon/live/app/javascript/mastodon/features/ui/util/intersection_observer_wrapper.js"],"names":["IntersectionObserverWrapper","callbacks","observerBacklog","observer","connect","options","onIntersection","entries","forEach","entry","id","target","getAttribute","IntersectionObserver","node","callback","observe","push","unobserve","disconnect"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;IAEMA,2B;;SAEJC,S,GAAY,E;SACZC,e,GAAkB,E;SAClBC,Q,GAAW,I;;;;;SAEXC,O,GAAA,iBAASC,OAAT,EAAkB;AAAA;;AAChB,QAAMC,cAAc,GAAG,SAAjBA,cAAiB,CAACC,OAAD,EAAa;AAClCA,MAAAA,OAAO,CAACC,OAAR,CAAgB,UAAAC,KAAK,EAAI;AACvB,YAAMC,EAAE,GAAGD,KAAK,CAACE,MAAN,CAAaC,YAAb,CAA0B,SAA1B,CAAX;;AACA,YAAI,KAAI,CAACX,SAAL,CAAeS,EAAf,CAAJ,EAAwB;AACtB,UAAA,KAAI,CAACT,SAAL,CAAeS,EAAf,EAAmBD,KAAnB;AACD;AACF,OALD;AAMD,KAPD;;AASA,SAAKN,QAAL,GAAgB,IAAIU,oBAAJ,CAAyBP,cAAzB,EAAyCD,OAAzC,CAAhB;AACA,SAAKH,eAAL,CAAqBM,OAArB,CAA6B,gBAA4B;AAAA,UAAzBE,EAAyB;AAAA,UAArBI,IAAqB;AAAA,UAAfC,QAAe;;AACvD,MAAA,KAAI,CAACC,OAAL,CAAaN,EAAb,EAAiBI,IAAjB,EAAuBC,QAAvB;AACD,KAFD;AAGA,SAAKb,eAAL,GAAuB,IAAvB;AACD,G;;SAEDc,O,GAAA,iBAASN,EAAT,EAAaI,IAAb,EAAmBC,QAAnB,EAA6B;AAC3B,QAAI,CAAC,KAAKZ,QAAV,EAAoB;AAClB,WAAKD,eAAL,CAAqBe,IAArB,CAA0B,CAAEP,EAAF,EAAMI,IAAN,EAAYC,QAAZ,CAA1B;AACD,KAFD,MAEO;AACL,WAAKd,SAAL,CAAeS,EAAf,IAAqBK,QAArB;AACA,WAAKZ,QAAL,CAAca,OAAd,CAAsBF,IAAtB;AACD;AACF,G;;SAEDI,S,GAAA,mBAAWR,EAAX,EAAeI,IAAf,EAAqB;AACnB,QAAI,KAAKX,QAAT,EAAmB;AACjB,aAAO,KAAKF,SAAL,CAAeS,EAAf,CAAP;AACA,WAAKP,QAAL,CAAce,SAAd,CAAwBJ,IAAxB;AACD;AACF,G;;SAEDK,U,GAAA,sBAAc;AACZ,QAAI,KAAKhB,QAAT,EAAmB;AACjB,WAAKF,SAAL,GAAiB,EAAjB;AACA,WAAKE,QAAL,CAAcgB,UAAd;AACA,WAAKhB,QAAL,GAAgB,IAAhB;AACD;AACF,G;;;;;AAIH,eAAeH,2BAAf","sourcesContent":["// Wrapper for IntersectionObserver in order to make working with it\n// a bit easier. We also follow this performance advice:\n// \"If you need to observe multiple elements, it is both possible and\n// advised to observe multiple elements using the same IntersectionObserver\n// instance by calling observe() multiple times.\"\n// https://developers.google.com/web/updates/2016/04/intersectionobserver\n\nclass IntersectionObserverWrapper {\n\n  callbacks = {};\n  observerBacklog = [];\n  observer = null;\n\n  connect (options) {\n    const onIntersection = (entries) => {\n      entries.forEach(entry => {\n        const id = entry.target.getAttribute('data-id');\n        if (this.callbacks[id]) {\n          this.callbacks[id](entry);\n        }\n      });\n    };\n\n    this.observer = new IntersectionObserver(onIntersection, options);\n    this.observerBacklog.forEach(([ id, node, callback ]) => {\n      this.observe(id, node, callback);\n    });\n    this.observerBacklog = null;\n  }\n\n  observe (id, node, callback) {\n    if (!this.observer) {\n      this.observerBacklog.push([ id, node, callback ]);\n    } else {\n      this.callbacks[id] = callback;\n      this.observer.observe(node);\n    }\n  }\n\n  unobserve (id, node) {\n    if (this.observer) {\n      delete this.callbacks[id];\n      this.observer.unobserve(node);\n    }\n  }\n\n  disconnect () {\n    if (this.observer) {\n      this.callbacks = {};\n      this.observer.disconnect();\n      this.observer = null;\n    }\n  }\n\n}\n\nexport default IntersectionObserverWrapper;\n"]},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module"}