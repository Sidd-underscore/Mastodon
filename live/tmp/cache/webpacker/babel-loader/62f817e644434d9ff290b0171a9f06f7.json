{"ast":null,"code":"var _jsxFileName = \"/home/runner/Mastodon/live/app/javascript/mastodon/components/scrollable_list.js\",\n    _dec,\n    _class,\n    _class2,\n    _temp;\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nimport React, { PureComponent } from 'react';\nimport ScrollContainer from 'mastodon/containers/scroll_container';\nimport PropTypes from 'prop-types';\nimport IntersectionObserverArticleContainer from '../containers/intersection_observer_article_container';\nimport LoadMore from './load_more';\nimport LoadPending from './load_pending';\nimport IntersectionObserverWrapper from '../features/ui/util/intersection_observer_wrapper';\nimport { throttle } from 'lodash';\nimport { List as ImmutableList } from 'immutable';\nimport classNames from 'classnames';\nimport { attachFullscreenListener, detachFullscreenListener, isFullscreen } from '../features/ui/util/fullscreen';\nimport LoadingIndicator from './loading_indicator';\nimport { connect } from 'react-redux';\nvar MOUSE_IDLE_DELAY = 300;\n\nvar mapStateToProps = function mapStateToProps(state, _ref) {\n  var scrollKey = _ref.scrollKey;\n  return {\n    preventScroll: scrollKey === state.getIn(['dropdown_menu', 'scroll_key'])\n  };\n};\n\nvar ScrollableList = (_dec = connect(mapStateToProps, null, null, {\n  forwardRef: true\n}), _dec(_class = (_temp = _class2 = /*#__PURE__*/function (_PureComponent) {\n  _inheritsLoose(ScrollableList, _PureComponent);\n\n  function ScrollableList() {\n    var _this;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _PureComponent.call.apply(_PureComponent, [this].concat(args)) || this;\n    _this.state = {\n      fullscreen: null,\n      cachedMediaWidth: 250 // Default media/card width using default Mastodon theme\n\n    };\n    _this.intersectionObserverWrapper = new IntersectionObserverWrapper();\n    _this.handleScroll = throttle(function () {\n      if (_this.node) {\n        var scrollTop = _this.getScrollTop();\n\n        var scrollHeight = _this.getScrollHeight();\n\n        var clientHeight = _this.getClientHeight();\n\n        var offset = scrollHeight - scrollTop - clientHeight;\n\n        if (400 > offset && _this.props.onLoadMore && _this.props.hasMore && !_this.props.isLoading) {\n          _this.props.onLoadMore();\n        }\n\n        if (scrollTop < 100 && _this.props.onScrollToTop) {\n          _this.props.onScrollToTop();\n        } else if (_this.props.onScroll) {\n          _this.props.onScroll();\n        }\n\n        if (!_this.lastScrollWasSynthetic) {\n          // If the last scroll wasn't caused by setScrollTop(), assume it was\n          // intentional and cancel any pending scroll reset on mouse idle\n          _this.scrollToTopOnMouseIdle = false;\n        }\n\n        _this.lastScrollWasSynthetic = false;\n      }\n    }, 150, {\n      trailing: true\n    });\n    _this.mouseIdleTimer = null;\n    _this.mouseMovedRecently = false;\n    _this.lastScrollWasSynthetic = false;\n    _this.scrollToTopOnMouseIdle = false;\n\n    _this._getScrollingElement = function () {\n      if (_this.props.bindToDocument) {\n        return document.scrollingElement || document.body;\n      } else {\n        return _this.node;\n      }\n    };\n\n    _this.setScrollTop = function (newScrollTop) {\n      if (_this.getScrollTop() !== newScrollTop) {\n        _this.lastScrollWasSynthetic = true;\n        _this._getScrollingElement().scrollTop = newScrollTop;\n      }\n    };\n\n    _this.clearMouseIdleTimer = function () {\n      if (_this.mouseIdleTimer === null) {\n        return;\n      }\n\n      clearTimeout(_this.mouseIdleTimer);\n      _this.mouseIdleTimer = null;\n    };\n\n    _this.handleMouseMove = throttle(function () {\n      // As long as the mouse keeps moving, clear and restart the idle timer.\n      _this.clearMouseIdleTimer();\n\n      _this.mouseIdleTimer = setTimeout(_this.handleMouseIdle, MOUSE_IDLE_DELAY);\n\n      if (!_this.mouseMovedRecently && _this.getScrollTop() === 0) {\n        // Only set if we just started moving and are scrolled to the top.\n        _this.scrollToTopOnMouseIdle = true;\n      } // Save setting this flag for last, so we can do the comparison above.\n\n\n      _this.mouseMovedRecently = true;\n    }, MOUSE_IDLE_DELAY / 2);\n    _this.handleWheel = throttle(function () {\n      _this.scrollToTopOnMouseIdle = false;\n    }, 150, {\n      trailing: true\n    });\n\n    _this.handleMouseIdle = function () {\n      if (_this.scrollToTopOnMouseIdle && !_this.props.preventScroll) {\n        _this.setScrollTop(0);\n      }\n\n      _this.mouseMovedRecently = false;\n      _this.scrollToTopOnMouseIdle = false;\n    };\n\n    _this.getScrollPosition = function () {\n      if (_this.node && (_this.getScrollTop() > 0 || _this.mouseMovedRecently)) {\n        return {\n          height: _this.getScrollHeight(),\n          top: _this.getScrollTop()\n        };\n      } else {\n        return null;\n      }\n    };\n\n    _this.getScrollTop = function () {\n      return _this._getScrollingElement().scrollTop;\n    };\n\n    _this.getScrollHeight = function () {\n      return _this._getScrollingElement().scrollHeight;\n    };\n\n    _this.getClientHeight = function () {\n      return _this._getScrollingElement().clientHeight;\n    };\n\n    _this.updateScrollBottom = function (snapshot) {\n      var newScrollTop = _this.getScrollHeight() - snapshot;\n\n      _this.setScrollTop(newScrollTop);\n    };\n\n    _this.cacheMediaWidth = function (width) {\n      if (width && _this.state.cachedMediaWidth !== width) {\n        _this.setState({\n          cachedMediaWidth: width\n        });\n      }\n    };\n\n    _this.onFullScreenChange = function () {\n      _this.setState({\n        fullscreen: isFullscreen()\n      });\n    };\n\n    _this.setRef = function (c) {\n      _this.node = c;\n    };\n\n    _this.handleLoadMore = function (e) {\n      e.preventDefault();\n\n      _this.props.onLoadMore();\n    };\n\n    _this.handleLoadPending = function (e) {\n      e.preventDefault();\n\n      _this.props.onLoadPending(); // Prevent the weird scroll-jumping behavior, as we explicitly don't want to\n      // scroll to top, and we know the scroll height is going to change\n\n\n      _this.scrollToTopOnMouseIdle = false;\n      _this.lastScrollWasSynthetic = false;\n\n      _this.clearMouseIdleTimer();\n\n      _this.mouseIdleTimer = setTimeout(_this.handleMouseIdle, MOUSE_IDLE_DELAY);\n      _this.mouseMovedRecently = true;\n    };\n\n    return _this;\n  }\n\n  var _proto = ScrollableList.prototype;\n\n  _proto.componentDidMount = function componentDidMount() {\n    this.attachScrollListener();\n    this.attachIntersectionObserver();\n    attachFullscreenListener(this.onFullScreenChange); // Handle initial scroll posiiton\n\n    this.handleScroll();\n  };\n\n  _proto.getSnapshotBeforeUpdate = function getSnapshotBeforeUpdate(prevProps) {\n    var someItemInserted = React.Children.count(prevProps.children) > 0 && React.Children.count(prevProps.children) < React.Children.count(this.props.children) && this.getFirstChildKey(prevProps) !== this.getFirstChildKey(this.props);\n    var pendingChanged = prevProps.numPending > 0 !== this.props.numPending > 0;\n\n    if (pendingChanged || someItemInserted && (this.getScrollTop() > 0 || this.mouseMovedRecently || this.props.preventScroll)) {\n      return this.getScrollHeight() - this.getScrollTop();\n    } else {\n      return null;\n    }\n  };\n\n  _proto.componentDidUpdate = function componentDidUpdate(prevProps, prevState, snapshot) {\n    // Reset the scroll position when a new child comes in in order not to\n    // jerk the scrollbar around if you're already scrolled down the page.\n    if (snapshot !== null) {\n      this.setScrollTop(this.getScrollHeight() - snapshot);\n    }\n  };\n\n  _proto.componentWillUnmount = function componentWillUnmount() {\n    this.clearMouseIdleTimer();\n    this.detachScrollListener();\n    this.detachIntersectionObserver();\n    detachFullscreenListener(this.onFullScreenChange);\n  };\n\n  _proto.attachIntersectionObserver = function attachIntersectionObserver() {\n    var nodeOptions = {\n      root: this.node,\n      rootMargin: '300% 0px'\n    };\n    this.intersectionObserverWrapper.connect(this.props.bindToDocument ? {} : nodeOptions);\n  };\n\n  _proto.detachIntersectionObserver = function detachIntersectionObserver() {\n    this.intersectionObserverWrapper.disconnect();\n  };\n\n  _proto.attachScrollListener = function attachScrollListener() {\n    if (this.props.bindToDocument) {\n      document.addEventListener('scroll', this.handleScroll);\n      document.addEventListener('wheel', this.handleWheel);\n    } else {\n      this.node.addEventListener('scroll', this.handleScroll);\n      this.node.addEventListener('wheel', this.handleWheel);\n    }\n  };\n\n  _proto.detachScrollListener = function detachScrollListener() {\n    if (this.props.bindToDocument) {\n      document.removeEventListener('scroll', this.handleScroll);\n      document.removeEventListener('wheel', this.handleWheel);\n    } else {\n      this.node.removeEventListener('scroll', this.handleScroll);\n      this.node.removeEventListener('wheel', this.handleWheel);\n    }\n  };\n\n  _proto.getFirstChildKey = function getFirstChildKey(props) {\n    var children = props.children;\n    var firstChild = children;\n\n    if (children instanceof ImmutableList) {\n      firstChild = children.get(0);\n    } else if (Array.isArray(children)) {\n      firstChild = children[0];\n    }\n\n    return firstChild && firstChild.key;\n  };\n\n  _proto.render = function render() {\n    var _this2 = this;\n\n    var _this$props = this.props,\n        children = _this$props.children,\n        scrollKey = _this$props.scrollKey,\n        trackScroll = _this$props.trackScroll,\n        showLoading = _this$props.showLoading,\n        isLoading = _this$props.isLoading,\n        hasMore = _this$props.hasMore,\n        numPending = _this$props.numPending,\n        prepend = _this$props.prepend,\n        alwaysPrepend = _this$props.alwaysPrepend,\n        append = _this$props.append,\n        emptyMessage = _this$props.emptyMessage,\n        onLoadMore = _this$props.onLoadMore;\n    var fullscreen = this.state.fullscreen;\n    var childrenCount = React.Children.count(children);\n    var loadMore = hasMore && onLoadMore ? /*#__PURE__*/React.createElement(LoadMore, {\n      visible: !isLoading,\n      onClick: this.handleLoadMore,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 296,\n        columnNumber: 52\n      }\n    }) : null;\n    var loadPending = numPending > 0 ? /*#__PURE__*/React.createElement(LoadPending, {\n      count: numPending,\n      onClick: this.handleLoadPending,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 297,\n        columnNumber: 45\n      }\n    }) : null;\n    var scrollableArea = null;\n\n    if (showLoading) {\n      scrollableArea = /*#__PURE__*/React.createElement(\"div\", {\n        className: \"scrollable scrollable--flex\",\n        ref: this.setRef,\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 302,\n          columnNumber: 9\n        }\n      }, /*#__PURE__*/React.createElement(\"div\", {\n        role: \"feed\",\n        className: \"item-list\",\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 303,\n          columnNumber: 11\n        }\n      }, prepend), /*#__PURE__*/React.createElement(\"div\", {\n        className: \"scrollable__append\",\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 307,\n          columnNumber: 11\n        }\n      }, /*#__PURE__*/React.createElement(LoadingIndicator, {\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 308,\n          columnNumber: 13\n        }\n      })));\n    } else if (isLoading || childrenCount > 0 || numPending > 0 || hasMore || !emptyMessage) {\n      scrollableArea = /*#__PURE__*/React.createElement(\"div\", {\n        className: classNames('scrollable', {\n          fullscreen\n        }),\n        ref: this.setRef,\n        onMouseMove: this.handleMouseMove,\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 314,\n          columnNumber: 9\n        }\n      }, /*#__PURE__*/React.createElement(\"div\", {\n        role: \"feed\",\n        className: \"item-list\",\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 315,\n          columnNumber: 11\n        }\n      }, prepend, loadPending, React.Children.map(this.props.children, function (child, index) {\n        return /*#__PURE__*/React.createElement(IntersectionObserverArticleContainer, {\n          key: child.key,\n          id: child.key,\n          index: index,\n          listLength: childrenCount,\n          intersectionObserverWrapper: _this2.intersectionObserverWrapper,\n          saveHeightKey: trackScroll ? _this2.context.router.route.location.key + \":\" + scrollKey : null,\n          __self: _this2,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 321,\n            columnNumber: 15\n          }\n        }, /*#__PURE__*/React.cloneElement(child, {\n          getScrollPosition: _this2.getScrollPosition,\n          updateScrollBottom: _this2.updateScrollBottom,\n          cachedMediaWidth: _this2.state.cachedMediaWidth,\n          cacheMediaWidth: _this2.cacheMediaWidth\n        }));\n      }), loadMore, !hasMore && append));\n    } else {\n      scrollableArea = /*#__PURE__*/React.createElement(\"div\", {\n        className: classNames('scrollable scrollable--flex', {\n          fullscreen\n        }),\n        ref: this.setRef,\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 346,\n          columnNumber: 9\n        }\n      }, alwaysPrepend && prepend, /*#__PURE__*/React.createElement(\"div\", {\n        className: \"empty-column-indicator\",\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 349,\n          columnNumber: 11\n        }\n      }, emptyMessage));\n    }\n\n    if (trackScroll) {\n      return /*#__PURE__*/React.createElement(ScrollContainer, {\n        scrollKey: scrollKey,\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 358,\n          columnNumber: 9\n        }\n      }, scrollableArea);\n    } else {\n      return scrollableArea;\n    }\n  };\n\n  return ScrollableList;\n}(PureComponent), _class2.contextTypes = {\n  router: PropTypes.object\n}, _class2.propTypes = {\n  scrollKey: PropTypes.string.isRequired,\n  onLoadMore: PropTypes.func,\n  onLoadPending: PropTypes.func,\n  onScrollToTop: PropTypes.func,\n  onScroll: PropTypes.func,\n  trackScroll: PropTypes.bool,\n  isLoading: PropTypes.bool,\n  showLoading: PropTypes.bool,\n  hasMore: PropTypes.bool,\n  numPending: PropTypes.number,\n  prepend: PropTypes.node,\n  append: PropTypes.node,\n  alwaysPrepend: PropTypes.bool,\n  emptyMessage: PropTypes.node,\n  children: PropTypes.node,\n  bindToDocument: PropTypes.bool,\n  preventScroll: PropTypes.bool\n}, _class2.defaultProps = {\n  trackScroll: true\n}, _temp)) || _class);\nexport { ScrollableList as default };","map":{"version":3,"sources":["/home/runner/Mastodon/live/app/javascript/mastodon/components/scrollable_list.js"],"names":["React","PureComponent","ScrollContainer","PropTypes","IntersectionObserverArticleContainer","LoadMore","LoadPending","IntersectionObserverWrapper","throttle","List","ImmutableList","classNames","attachFullscreenListener","detachFullscreenListener","isFullscreen","LoadingIndicator","connect","MOUSE_IDLE_DELAY","mapStateToProps","state","scrollKey","preventScroll","getIn","ScrollableList","forwardRef","fullscreen","cachedMediaWidth","intersectionObserverWrapper","handleScroll","node","scrollTop","getScrollTop","scrollHeight","getScrollHeight","clientHeight","getClientHeight","offset","props","onLoadMore","hasMore","isLoading","onScrollToTop","onScroll","lastScrollWasSynthetic","scrollToTopOnMouseIdle","trailing","mouseIdleTimer","mouseMovedRecently","_getScrollingElement","bindToDocument","document","scrollingElement","body","setScrollTop","newScrollTop","clearMouseIdleTimer","clearTimeout","handleMouseMove","setTimeout","handleMouseIdle","handleWheel","getScrollPosition","height","top","updateScrollBottom","snapshot","cacheMediaWidth","width","setState","onFullScreenChange","setRef","c","handleLoadMore","e","preventDefault","handleLoadPending","onLoadPending","componentDidMount","attachScrollListener","attachIntersectionObserver","getSnapshotBeforeUpdate","prevProps","someItemInserted","Children","count","children","getFirstChildKey","pendingChanged","numPending","componentDidUpdate","prevState","componentWillUnmount","detachScrollListener","detachIntersectionObserver","nodeOptions","root","rootMargin","disconnect","addEventListener","removeEventListener","firstChild","get","Array","isArray","key","render","trackScroll","showLoading","prepend","alwaysPrepend","append","emptyMessage","childrenCount","loadMore","loadPending","scrollableArea","map","child","index","context","router","route","location","cloneElement","contextTypes","object","propTypes","string","isRequired","func","bool","number","defaultProps"],"mappings":"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","sourcesContent":["import React, { PureComponent } from 'react';\nimport ScrollContainer from 'mastodon/containers/scroll_container';\nimport PropTypes from 'prop-types';\nimport IntersectionObserverArticleContainer from '../containers/intersection_observer_article_container';\nimport LoadMore from './load_more';\nimport LoadPending from './load_pending';\nimport IntersectionObserverWrapper from '../features/ui/util/intersection_observer_wrapper';\nimport { throttle } from 'lodash';\nimport { List as ImmutableList } from 'immutable';\nimport classNames from 'classnames';\nimport { attachFullscreenListener, detachFullscreenListener, isFullscreen } from '../features/ui/util/fullscreen';\nimport LoadingIndicator from './loading_indicator';\nimport { connect } from 'react-redux';\n\nconst MOUSE_IDLE_DELAY = 300;\n\nconst mapStateToProps = (state, { scrollKey }) => {\n  return {\n    preventScroll: scrollKey === state.getIn(['dropdown_menu', 'scroll_key']),\n  };\n};\n\nexport default @connect(mapStateToProps, null, null, { forwardRef: true })\nclass ScrollableList extends PureComponent {\n\n  static contextTypes = {\n    router: PropTypes.object,\n  };\n\n  static propTypes = {\n    scrollKey: PropTypes.string.isRequired,\n    onLoadMore: PropTypes.func,\n    onLoadPending: PropTypes.func,\n    onScrollToTop: PropTypes.func,\n    onScroll: PropTypes.func,\n    trackScroll: PropTypes.bool,\n    isLoading: PropTypes.bool,\n    showLoading: PropTypes.bool,\n    hasMore: PropTypes.bool,\n    numPending: PropTypes.number,\n    prepend: PropTypes.node,\n    append: PropTypes.node,\n    alwaysPrepend: PropTypes.bool,\n    emptyMessage: PropTypes.node,\n    children: PropTypes.node,\n    bindToDocument: PropTypes.bool,\n    preventScroll: PropTypes.bool,\n  };\n\n  static defaultProps = {\n    trackScroll: true,\n  };\n\n  state = {\n    fullscreen: null,\n    cachedMediaWidth: 250, // Default media/card width using default Mastodon theme\n  };\n\n  intersectionObserverWrapper = new IntersectionObserverWrapper();\n\n  handleScroll = throttle(() => {\n    if (this.node) {\n      const scrollTop = this.getScrollTop();\n      const scrollHeight = this.getScrollHeight();\n      const clientHeight = this.getClientHeight();\n      const offset = scrollHeight - scrollTop - clientHeight;\n\n      if (400 > offset && this.props.onLoadMore && this.props.hasMore && !this.props.isLoading) {\n        this.props.onLoadMore();\n      }\n\n      if (scrollTop < 100 && this.props.onScrollToTop) {\n        this.props.onScrollToTop();\n      } else if (this.props.onScroll) {\n        this.props.onScroll();\n      }\n\n      if (!this.lastScrollWasSynthetic) {\n        // If the last scroll wasn't caused by setScrollTop(), assume it was\n        // intentional and cancel any pending scroll reset on mouse idle\n        this.scrollToTopOnMouseIdle = false;\n      }\n      this.lastScrollWasSynthetic = false;\n    }\n  }, 150, {\n    trailing: true,\n  });\n\n  mouseIdleTimer = null;\n  mouseMovedRecently = false;\n  lastScrollWasSynthetic = false;\n  scrollToTopOnMouseIdle = false;\n\n  _getScrollingElement = () => {\n    if (this.props.bindToDocument) {\n      return (document.scrollingElement || document.body);\n    } else {\n      return this.node;\n    }\n  }\n\n  setScrollTop = newScrollTop => {\n    if (this.getScrollTop() !== newScrollTop) {\n      this.lastScrollWasSynthetic = true;\n\n      this._getScrollingElement().scrollTop = newScrollTop;\n    }\n  };\n\n  clearMouseIdleTimer = () => {\n    if (this.mouseIdleTimer === null) {\n      return;\n    }\n\n    clearTimeout(this.mouseIdleTimer);\n    this.mouseIdleTimer = null;\n  };\n\n  handleMouseMove = throttle(() => {\n    // As long as the mouse keeps moving, clear and restart the idle timer.\n    this.clearMouseIdleTimer();\n    this.mouseIdleTimer = setTimeout(this.handleMouseIdle, MOUSE_IDLE_DELAY);\n\n    if (!this.mouseMovedRecently && this.getScrollTop() === 0) {\n      // Only set if we just started moving and are scrolled to the top.\n      this.scrollToTopOnMouseIdle = true;\n    }\n\n    // Save setting this flag for last, so we can do the comparison above.\n    this.mouseMovedRecently = true;\n  }, MOUSE_IDLE_DELAY / 2);\n\n  handleWheel = throttle(() => {\n    this.scrollToTopOnMouseIdle = false;\n  }, 150, {\n    trailing: true,\n  });\n\n  handleMouseIdle = () => {\n    if (this.scrollToTopOnMouseIdle && !this.props.preventScroll) {\n      this.setScrollTop(0);\n    }\n\n    this.mouseMovedRecently = false;\n    this.scrollToTopOnMouseIdle = false;\n  }\n\n  componentDidMount () {\n    this.attachScrollListener();\n    this.attachIntersectionObserver();\n\n    attachFullscreenListener(this.onFullScreenChange);\n\n    // Handle initial scroll posiiton\n    this.handleScroll();\n  }\n\n  getScrollPosition = () => {\n    if (this.node && (this.getScrollTop() > 0 || this.mouseMovedRecently)) {\n      return { height: this.getScrollHeight(), top: this.getScrollTop() };\n    } else {\n      return null;\n    }\n  }\n\n  getScrollTop = () => {\n    return this._getScrollingElement().scrollTop;\n  }\n\n  getScrollHeight = () => {\n    return this._getScrollingElement().scrollHeight;\n  }\n\n  getClientHeight = () => {\n    return this._getScrollingElement().clientHeight;\n  }\n\n  updateScrollBottom = (snapshot) => {\n    const newScrollTop = this.getScrollHeight() - snapshot;\n\n    this.setScrollTop(newScrollTop);\n  }\n\n  getSnapshotBeforeUpdate (prevProps) {\n    const someItemInserted = React.Children.count(prevProps.children) > 0 &&\n      React.Children.count(prevProps.children) < React.Children.count(this.props.children) &&\n      this.getFirstChildKey(prevProps) !== this.getFirstChildKey(this.props);\n    const pendingChanged = (prevProps.numPending > 0) !== (this.props.numPending > 0);\n\n    if (pendingChanged || someItemInserted && (this.getScrollTop() > 0 || this.mouseMovedRecently || this.props.preventScroll)) {\n      return this.getScrollHeight() - this.getScrollTop();\n    } else {\n      return null;\n    }\n  }\n\n  componentDidUpdate (prevProps, prevState, snapshot) {\n    // Reset the scroll position when a new child comes in in order not to\n    // jerk the scrollbar around if you're already scrolled down the page.\n    if (snapshot !== null) {\n      this.setScrollTop(this.getScrollHeight() - snapshot);\n    }\n  }\n\n  cacheMediaWidth = (width) => {\n    if (width && this.state.cachedMediaWidth !== width) {\n      this.setState({ cachedMediaWidth: width });\n    }\n  }\n\n  componentWillUnmount () {\n    this.clearMouseIdleTimer();\n    this.detachScrollListener();\n    this.detachIntersectionObserver();\n\n    detachFullscreenListener(this.onFullScreenChange);\n  }\n\n  onFullScreenChange = () => {\n    this.setState({ fullscreen: isFullscreen() });\n  }\n\n  attachIntersectionObserver () {\n    let nodeOptions = {\n      root: this.node,\n      rootMargin: '300% 0px',\n    };\n\n    this.intersectionObserverWrapper\n      .connect(this.props.bindToDocument ? {} : nodeOptions);\n  }\n\n  detachIntersectionObserver () {\n    this.intersectionObserverWrapper.disconnect();\n  }\n\n  attachScrollListener () {\n    if (this.props.bindToDocument) {\n      document.addEventListener('scroll', this.handleScroll);\n      document.addEventListener('wheel', this.handleWheel);\n    } else {\n      this.node.addEventListener('scroll', this.handleScroll);\n      this.node.addEventListener('wheel', this.handleWheel);\n    }\n  }\n\n  detachScrollListener () {\n    if (this.props.bindToDocument) {\n      document.removeEventListener('scroll', this.handleScroll);\n      document.removeEventListener('wheel', this.handleWheel);\n    } else {\n      this.node.removeEventListener('scroll', this.handleScroll);\n      this.node.removeEventListener('wheel', this.handleWheel);\n    }\n  }\n\n  getFirstChildKey (props) {\n    const { children } = props;\n    let firstChild     = children;\n\n    if (children instanceof ImmutableList) {\n      firstChild = children.get(0);\n    } else if (Array.isArray(children)) {\n      firstChild = children[0];\n    }\n\n    return firstChild && firstChild.key;\n  }\n\n  setRef = (c) => {\n    this.node = c;\n  }\n\n  handleLoadMore = e => {\n    e.preventDefault();\n    this.props.onLoadMore();\n  }\n\n  handleLoadPending = e => {\n    e.preventDefault();\n    this.props.onLoadPending();\n    // Prevent the weird scroll-jumping behavior, as we explicitly don't want to\n    // scroll to top, and we know the scroll height is going to change\n    this.scrollToTopOnMouseIdle = false;\n    this.lastScrollWasSynthetic = false;\n    this.clearMouseIdleTimer();\n    this.mouseIdleTimer = setTimeout(this.handleMouseIdle, MOUSE_IDLE_DELAY);\n    this.mouseMovedRecently = true;\n  }\n\n  render () {\n    const { children, scrollKey, trackScroll, showLoading, isLoading, hasMore, numPending, prepend, alwaysPrepend, append, emptyMessage, onLoadMore } = this.props;\n    const { fullscreen } = this.state;\n    const childrenCount = React.Children.count(children);\n\n    const loadMore     = (hasMore && onLoadMore) ? <LoadMore visible={!isLoading} onClick={this.handleLoadMore} /> : null;\n    const loadPending  = (numPending > 0) ? <LoadPending count={numPending} onClick={this.handleLoadPending} /> : null;\n    let scrollableArea = null;\n\n    if (showLoading) {\n      scrollableArea = (\n        <div className='scrollable scrollable--flex' ref={this.setRef}>\n          <div role='feed' className='item-list'>\n            {prepend}\n          </div>\n\n          <div className='scrollable__append'>\n            <LoadingIndicator />\n          </div>\n        </div>\n      );\n    } else if (isLoading || childrenCount > 0 || numPending > 0 || hasMore || !emptyMessage) {\n      scrollableArea = (\n        <div className={classNames('scrollable', { fullscreen })} ref={this.setRef} onMouseMove={this.handleMouseMove}>\n          <div role='feed' className='item-list'>\n            {prepend}\n\n            {loadPending}\n\n            {React.Children.map(this.props.children, (child, index) => (\n              <IntersectionObserverArticleContainer\n                key={child.key}\n                id={child.key}\n                index={index}\n                listLength={childrenCount}\n                intersectionObserverWrapper={this.intersectionObserverWrapper}\n                saveHeightKey={trackScroll ? `${this.context.router.route.location.key}:${scrollKey}` : null}\n              >\n                {React.cloneElement(child, {\n                  getScrollPosition: this.getScrollPosition,\n                  updateScrollBottom: this.updateScrollBottom,\n                  cachedMediaWidth: this.state.cachedMediaWidth,\n                  cacheMediaWidth: this.cacheMediaWidth,\n                })}\n              </IntersectionObserverArticleContainer>\n            ))}\n\n            {loadMore}\n\n            {!hasMore && append}\n          </div>\n        </div>\n      );\n    } else {\n      scrollableArea = (\n        <div className={classNames('scrollable scrollable--flex', { fullscreen })} ref={this.setRef}>\n          {alwaysPrepend && prepend}\n\n          <div className='empty-column-indicator'>\n            {emptyMessage}\n          </div>\n        </div>\n      );\n    }\n\n    if (trackScroll) {\n      return (\n        <ScrollContainer scrollKey={scrollKey}>\n          {scrollableArea}\n        </ScrollContainer>\n      );\n    } else {\n      return scrollableArea;\n    }\n  }\n\n}\n"]},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module"}