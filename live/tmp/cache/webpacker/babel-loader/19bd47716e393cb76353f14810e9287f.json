{"ast":null,"code":"var _jsxFileName = \"/home/runner/Mastodon/live/app/javascript/mastodon/components/intersection_observer_article.js\";\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport scheduleIdleTask from '../features/ui/util/schedule_idle_task';\nimport getRectFromEntry from '../features/ui/util/get_rect_from_entry'; // Diff these props in the \"unrendered\" state\n\nvar updateOnPropsForUnrendered = ['id', 'index', 'listLength', 'cachedHeight'];\n\nvar IntersectionObserverArticle = /*#__PURE__*/function (_React$Component) {\n  _inheritsLoose(IntersectionObserverArticle, _React$Component);\n\n  function IntersectionObserverArticle() {\n    var _this;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;\n    _this.state = {\n      isHidden: false // set to true in requestIdleCallback to trigger un-render\n\n    };\n\n    _this.handleIntersection = function (entry) {\n      _this.entry = entry;\n      scheduleIdleTask(_this.calculateHeight);\n\n      _this.setState(_this.updateStateAfterIntersection);\n    };\n\n    _this.updateStateAfterIntersection = function (prevState) {\n      if (prevState.isIntersecting !== false && !_this.entry.isIntersecting) {\n        scheduleIdleTask(_this.hideIfNotIntersecting);\n      }\n\n      return {\n        isIntersecting: _this.entry.isIntersecting,\n        isHidden: false\n      };\n    };\n\n    _this.calculateHeight = function () {\n      var _this$props = _this.props,\n          onHeightChange = _this$props.onHeightChange,\n          saveHeightKey = _this$props.saveHeightKey,\n          id = _this$props.id; // save the height of the fully-rendered element (this is expensive\n      // on Chrome, where we need to fall back to getBoundingClientRect)\n\n      _this.height = getRectFromEntry(_this.entry).height;\n\n      if (onHeightChange && saveHeightKey) {\n        onHeightChange(saveHeightKey, id, _this.height);\n      }\n    };\n\n    _this.hideIfNotIntersecting = function () {\n      if (!_this.componentMounted) {\n        return;\n      } // When the browser gets a chance, test if we're still not intersecting,\n      // and if so, set our isHidden to true to trigger an unrender. The point of\n      // this is to save DOM nodes and avoid using up too much memory.\n      // See: https://github.com/mastodon/mastodon/issues/2900\n\n\n      _this.setState(function (prevState) {\n        return {\n          isHidden: !prevState.isIntersecting\n        };\n      });\n    };\n\n    _this.handleRef = function (node) {\n      _this.node = node;\n    };\n\n    return _this;\n  }\n\n  var _proto = IntersectionObserverArticle.prototype;\n\n  _proto.shouldComponentUpdate = function shouldComponentUpdate(nextProps, nextState) {\n    var _this2 = this;\n\n    var isUnrendered = !this.state.isIntersecting && (this.state.isHidden || this.props.cachedHeight);\n    var willBeUnrendered = !nextState.isIntersecting && (nextState.isHidden || nextProps.cachedHeight);\n\n    if (!!isUnrendered !== !!willBeUnrendered) {\n      // If we're going from rendered to unrendered (or vice versa) then update\n      return true;\n    } // If we are and remain hidden, diff based on props\n\n\n    if (isUnrendered) {\n      return !updateOnPropsForUnrendered.every(function (prop) {\n        return nextProps[prop] === _this2.props[prop];\n      });\n    } // Else, assume the children have changed\n\n\n    return true;\n  };\n\n  _proto.componentDidMount = function componentDidMount() {\n    var _this$props2 = this.props,\n        intersectionObserverWrapper = _this$props2.intersectionObserverWrapper,\n        id = _this$props2.id;\n    intersectionObserverWrapper.observe(id, this.node, this.handleIntersection);\n    this.componentMounted = true;\n  };\n\n  _proto.componentWillUnmount = function componentWillUnmount() {\n    var _this$props3 = this.props,\n        intersectionObserverWrapper = _this$props3.intersectionObserverWrapper,\n        id = _this$props3.id;\n    intersectionObserverWrapper.unobserve(id, this.node);\n    this.componentMounted = false;\n  };\n\n  _proto.render = function render() {\n    var _this$props4 = this.props,\n        children = _this$props4.children,\n        id = _this$props4.id,\n        index = _this$props4.index,\n        listLength = _this$props4.listLength,\n        cachedHeight = _this$props4.cachedHeight;\n    var _this$state = this.state,\n        isIntersecting = _this$state.isIntersecting,\n        isHidden = _this$state.isHidden;\n\n    if (!isIntersecting && (isHidden || cachedHeight)) {\n      return /*#__PURE__*/React.createElement(\"article\", {\n        ref: this.handleRef,\n        \"aria-posinset\": index + 1,\n        \"aria-setsize\": listLength,\n        style: {\n          height: (this.height || cachedHeight) + \"px\",\n          opacity: 0,\n          overflow: 'hidden'\n        },\n        \"data-id\": id,\n        tabIndex: \"0\",\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 110,\n          columnNumber: 9\n        }\n      }, children && /*#__PURE__*/React.cloneElement(children, {\n        hidden: true\n      }));\n    }\n\n    return /*#__PURE__*/React.createElement(\"article\", {\n      ref: this.handleRef,\n      \"aria-posinset\": index + 1,\n      \"aria-setsize\": listLength,\n      \"data-id\": id,\n      tabIndex: \"0\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 124,\n        columnNumber: 7\n      }\n    }, children && /*#__PURE__*/React.cloneElement(children, {\n      hidden: false\n    }));\n  };\n\n  return IntersectionObserverArticle;\n}(React.Component);\n\nIntersectionObserverArticle.propTypes = {\n  intersectionObserverWrapper: PropTypes.object.isRequired,\n  id: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n  index: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n  listLength: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n  saveHeightKey: PropTypes.string,\n  cachedHeight: PropTypes.number,\n  onHeightChange: PropTypes.func,\n  children: PropTypes.node\n};\nexport { IntersectionObserverArticle as default };","map":{"version":3,"sources":["/home/runner/Mastodon/live/app/javascript/mastodon/components/intersection_observer_article.js"],"names":["React","PropTypes","scheduleIdleTask","getRectFromEntry","updateOnPropsForUnrendered","IntersectionObserverArticle","state","isHidden","handleIntersection","entry","calculateHeight","setState","updateStateAfterIntersection","prevState","isIntersecting","hideIfNotIntersecting","props","onHeightChange","saveHeightKey","id","height","componentMounted","handleRef","node","shouldComponentUpdate","nextProps","nextState","isUnrendered","cachedHeight","willBeUnrendered","every","prop","componentDidMount","intersectionObserverWrapper","observe","componentWillUnmount","unobserve","render","children","index","listLength","opacity","overflow","cloneElement","hidden","Component","propTypes","object","isRequired","oneOfType","string","number","func"],"mappings":"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","sourcesContent":["import React from 'react';\nimport PropTypes from 'prop-types';\nimport scheduleIdleTask from '../features/ui/util/schedule_idle_task';\nimport getRectFromEntry from '../features/ui/util/get_rect_from_entry';\n\n// Diff these props in the \"unrendered\" state\nconst updateOnPropsForUnrendered = ['id', 'index', 'listLength', 'cachedHeight'];\n\nexport default class IntersectionObserverArticle extends React.Component {\n\n  static propTypes = {\n    intersectionObserverWrapper: PropTypes.object.isRequired,\n    id: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n    index: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n    listLength: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n    saveHeightKey: PropTypes.string,\n    cachedHeight: PropTypes.number,\n    onHeightChange: PropTypes.func,\n    children: PropTypes.node,\n  };\n\n  state = {\n    isHidden: false, // set to true in requestIdleCallback to trigger un-render\n  }\n\n  shouldComponentUpdate (nextProps, nextState) {\n    const isUnrendered = !this.state.isIntersecting && (this.state.isHidden || this.props.cachedHeight);\n    const willBeUnrendered = !nextState.isIntersecting && (nextState.isHidden || nextProps.cachedHeight);\n    if (!!isUnrendered !== !!willBeUnrendered) {\n      // If we're going from rendered to unrendered (or vice versa) then update\n      return true;\n    }\n    // If we are and remain hidden, diff based on props\n    if (isUnrendered) {\n      return !updateOnPropsForUnrendered.every(prop => nextProps[prop] === this.props[prop]);\n    }\n    // Else, assume the children have changed\n    return true;\n  }\n\n  componentDidMount () {\n    const { intersectionObserverWrapper, id } = this.props;\n\n    intersectionObserverWrapper.observe(\n      id,\n      this.node,\n      this.handleIntersection,\n    );\n\n    this.componentMounted = true;\n  }\n\n  componentWillUnmount () {\n    const { intersectionObserverWrapper, id } = this.props;\n    intersectionObserverWrapper.unobserve(id, this.node);\n\n    this.componentMounted = false;\n  }\n\n  handleIntersection = (entry) => {\n    this.entry = entry;\n\n    scheduleIdleTask(this.calculateHeight);\n    this.setState(this.updateStateAfterIntersection);\n  }\n\n  updateStateAfterIntersection = (prevState) => {\n    if (prevState.isIntersecting !== false && !this.entry.isIntersecting) {\n      scheduleIdleTask(this.hideIfNotIntersecting);\n    }\n    return {\n      isIntersecting: this.entry.isIntersecting,\n      isHidden: false,\n    };\n  }\n\n  calculateHeight = () => {\n    const { onHeightChange, saveHeightKey, id } = this.props;\n    // save the height of the fully-rendered element (this is expensive\n    // on Chrome, where we need to fall back to getBoundingClientRect)\n    this.height = getRectFromEntry(this.entry).height;\n\n    if (onHeightChange && saveHeightKey) {\n      onHeightChange(saveHeightKey, id, this.height);\n    }\n  }\n\n  hideIfNotIntersecting = () => {\n    if (!this.componentMounted) {\n      return;\n    }\n\n    // When the browser gets a chance, test if we're still not intersecting,\n    // and if so, set our isHidden to true to trigger an unrender. The point of\n    // this is to save DOM nodes and avoid using up too much memory.\n    // See: https://github.com/mastodon/mastodon/issues/2900\n    this.setState((prevState) => ({ isHidden: !prevState.isIntersecting }));\n  }\n\n  handleRef = (node) => {\n    this.node = node;\n  }\n\n  render () {\n    const { children, id, index, listLength, cachedHeight } = this.props;\n    const { isIntersecting, isHidden } = this.state;\n\n    if (!isIntersecting && (isHidden || cachedHeight)) {\n      return (\n        <article\n          ref={this.handleRef}\n          aria-posinset={index + 1}\n          aria-setsize={listLength}\n          style={{ height: `${this.height || cachedHeight}px`, opacity: 0, overflow: 'hidden' }}\n          data-id={id}\n          tabIndex='0'\n        >\n          {children && React.cloneElement(children, { hidden: true })}\n        </article>\n      );\n    }\n\n    return (\n      <article ref={this.handleRef} aria-posinset={index + 1} aria-setsize={listLength} data-id={id} tabIndex='0'>\n        {children && React.cloneElement(children, { hidden: false })}\n      </article>\n    );\n  }\n\n}\n"]},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module"}