{"ast":null,"code":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\n// @ts-check\nimport WebSocketClient from '@gamestdio/websocket';\n/**\n * @type {WebSocketClient | undefined}\n */\n\nvar sharedConnection;\n/**\n * @typedef Subscription\n * @property {string} channelName\n * @property {Object.<string, string>} params\n * @property {function(): void} onConnect\n * @property {function(StreamEvent): void} onReceive\n * @property {function(): void} onDisconnect\n */\n\n/**\n  * @typedef StreamEvent\n  * @property {string} event\n  * @property {object} payload\n  */\n\n/**\n * @type {Array.<Subscription>}\n */\n\nvar subscriptions = [];\n/**\n * @type {Object.<string, number>}\n */\n\nvar subscriptionCounters = {};\n/**\n * @param {Subscription} subscription\n */\n\nvar addSubscription = function addSubscription(subscription) {\n  subscriptions.push(subscription);\n};\n/**\n * @param {Subscription} subscription\n */\n\n\nvar removeSubscription = function removeSubscription(subscription) {\n  var index = subscriptions.indexOf(subscription);\n\n  if (index !== -1) {\n    subscriptions.splice(index, 1);\n  }\n};\n/**\n * @param {Subscription} subscription\n */\n\n\nvar subscribe = function subscribe(_ref) {\n  var channelName = _ref.channelName,\n      params = _ref.params,\n      onConnect = _ref.onConnect;\n  var key = channelNameWithInlineParams(channelName, params);\n  subscriptionCounters[key] = subscriptionCounters[key] || 0;\n\n  if (subscriptionCounters[key] === 0) {\n    sharedConnection.send(JSON.stringify(_extends({\n      type: 'subscribe',\n      stream: channelName\n    }, params)));\n  }\n\n  subscriptionCounters[key] += 1;\n  onConnect();\n};\n/**\n * @param {Subscription} subscription\n */\n\n\nvar unsubscribe = function unsubscribe(_ref2) {\n  var channelName = _ref2.channelName,\n      params = _ref2.params,\n      onDisconnect = _ref2.onDisconnect;\n  var key = channelNameWithInlineParams(channelName, params);\n  subscriptionCounters[key] = subscriptionCounters[key] || 1;\n\n  if (subscriptionCounters[key] === 1 && sharedConnection.readyState === WebSocketClient.OPEN) {\n    sharedConnection.send(JSON.stringify(_extends({\n      type: 'unsubscribe',\n      stream: channelName\n    }, params)));\n  }\n\n  subscriptionCounters[key] -= 1;\n  onDisconnect();\n};\n\nvar sharedCallbacks = {\n  connected() {\n    subscriptions.forEach(function (subscription) {\n      return subscribe(subscription);\n    });\n  },\n\n  received(data) {\n    var stream = data.stream;\n    subscriptions.filter(function (_ref3) {\n      var channelName = _ref3.channelName,\n          params = _ref3.params;\n      var streamChannelName = stream[0];\n\n      if (stream.length === 1) {\n        return channelName === streamChannelName;\n      }\n\n      var streamIdentifier = stream[1];\n\n      if (['hashtag', 'hashtag:local'].includes(channelName)) {\n        return channelName === streamChannelName && params.tag === streamIdentifier;\n      } else if (channelName === 'list') {\n        return channelName === streamChannelName && params.list === streamIdentifier;\n      }\n\n      return false;\n    }).forEach(function (subscription) {\n      subscription.onReceive(data);\n    });\n  },\n\n  disconnected() {\n    subscriptions.forEach(function (subscription) {\n      return unsubscribe(subscription);\n    });\n  },\n\n  reconnected() {}\n\n};\n/**\n * @param {string} channelName\n * @param {Object.<string, string>} params\n * @return {string}\n */\n\nvar channelNameWithInlineParams = function channelNameWithInlineParams(channelName, params) {\n  if (Object.keys(params).length === 0) {\n    return channelName;\n  }\n\n  return channelName + \"&\" + Object.keys(params).map(function (key) {\n    return key + \"=\" + params[key];\n  }).join('&');\n};\n/**\n * @param {string} channelName\n * @param {Object.<string, string>} params\n * @param {function(Function, Function): { onConnect: (function(): void), onReceive: (function(StreamEvent): void), onDisconnect: (function(): void) }} callbacks\n * @return {function(): void}\n */\n\n\nexport var connectStream = function connectStream(channelName, params, callbacks) {\n  return function (dispatch, getState) {\n    var streamingAPIBaseURL = getState().getIn(['meta', 'streaming_api_base_url']);\n    var accessToken = getState().getIn(['meta', 'access_token']);\n\n    var _callbacks = callbacks(dispatch, getState),\n        onConnect = _callbacks.onConnect,\n        onReceive = _callbacks.onReceive,\n        onDisconnect = _callbacks.onDisconnect; // If we cannot use a websockets connection, we must fall back\n    // to using individual connections for each channel\n\n\n    if (!streamingAPIBaseURL.startsWith('ws')) {\n      var connection = createConnection(streamingAPIBaseURL, accessToken, channelNameWithInlineParams(channelName, params), {\n        connected() {\n          onConnect();\n        },\n\n        received(data) {\n          onReceive(data);\n        },\n\n        disconnected() {\n          onDisconnect();\n        },\n\n        reconnected() {\n          onConnect();\n        }\n\n      });\n      return function () {\n        connection.close();\n      };\n    }\n\n    var subscription = {\n      channelName,\n      params,\n      onConnect,\n      onReceive,\n      onDisconnect\n    };\n    addSubscription(subscription); // If a connection is open, we can execute the subscription right now. Otherwise,\n    // because we have already registered it, it will be executed on connect\n\n    if (!sharedConnection) {\n      sharedConnection =\n      /** @type {WebSocketClient} */\n      createConnection(streamingAPIBaseURL, accessToken, '', sharedCallbacks);\n    } else if (sharedConnection.readyState === WebSocketClient.OPEN) {\n      subscribe(subscription);\n    }\n\n    return function () {\n      removeSubscription(subscription);\n      unsubscribe(subscription);\n    };\n  };\n};\nvar KNOWN_EVENT_TYPES = ['update', 'delete', 'notification', 'conversation', 'filters_changed', 'encrypted_message', 'announcement', 'announcement.delete', 'announcement.reaction'];\n/**\n * @param {MessageEvent} e\n * @param {function(StreamEvent): void} received\n */\n\nvar handleEventSourceMessage = function handleEventSourceMessage(e, received) {\n  received({\n    event: e.type,\n    payload: e.data\n  });\n};\n/**\n * @param {string} streamingAPIBaseURL\n * @param {string} accessToken\n * @param {string} channelName\n * @param {{ connected: Function, received: function(StreamEvent): void, disconnected: Function, reconnected: Function }} callbacks\n * @return {WebSocketClient | EventSource}\n */\n\n\nvar createConnection = function createConnection(streamingAPIBaseURL, accessToken, channelName, _ref4) {\n  var connected = _ref4.connected,\n      received = _ref4.received,\n      disconnected = _ref4.disconnected,\n      reconnected = _ref4.reconnected;\n  var params = channelName.split('&');\n  channelName = params.shift();\n\n  if (streamingAPIBaseURL.startsWith('ws')) {\n    var ws = new WebSocketClient(streamingAPIBaseURL + \"/api/v1/streaming/?\" + params.join('&'), accessToken);\n    ws.onopen = connected;\n\n    ws.onmessage = function (e) {\n      return received(JSON.parse(e.data));\n    };\n\n    ws.onclose = disconnected;\n    ws.onreconnect = reconnected;\n    return ws;\n  }\n\n  channelName = channelName.replace(/:/g, '/');\n\n  if (channelName.endsWith(':media')) {\n    channelName = channelName.replace('/media', '');\n    params.push('only_media=true');\n  }\n\n  params.push(\"access_token=\" + accessToken);\n  var es = new EventSource(streamingAPIBaseURL + \"/api/v1/streaming/\" + channelName + \"?\" + params.join('&'));\n\n  es.onopen = function () {\n    connected();\n  };\n\n  KNOWN_EVENT_TYPES.forEach(function (type) {\n    es.addEventListener(type, function (e) {\n      return handleEventSourceMessage(\n      /** @type {MessageEvent} */\n      e, received);\n    });\n  });\n  es.onerror =\n  /** @type {function(): void} */\n  disconnected;\n  return es;\n};","map":{"version":3,"sources":["/home/runner/Mastodon/live/app/javascript/mastodon/stream.js"],"names":["WebSocketClient","sharedConnection","subscriptions","subscriptionCounters","addSubscription","subscription","push","removeSubscription","index","indexOf","splice","subscribe","channelName","params","onConnect","key","channelNameWithInlineParams","send","JSON","stringify","type","stream","unsubscribe","onDisconnect","readyState","OPEN","sharedCallbacks","connected","forEach","received","data","filter","streamChannelName","length","streamIdentifier","includes","tag","list","onReceive","disconnected","reconnected","Object","keys","map","join","connectStream","callbacks","dispatch","getState","streamingAPIBaseURL","getIn","accessToken","startsWith","connection","createConnection","close","KNOWN_EVENT_TYPES","handleEventSourceMessage","e","event","payload","split","shift","ws","onopen","onmessage","parse","onclose","onreconnect","replace","endsWith","es","EventSource","addEventListener","onerror"],"mappings":";;AAAA;AAEA,OAAOA,eAAP,MAA4B,sBAA5B;AAEA;AACA;AACA;;AACA,IAAIC,gBAAJ;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AACA,IAAMC,aAAa,GAAG,EAAtB;AAEA;AACA;AACA;;AACA,IAAMC,oBAAoB,GAAG,EAA7B;AAEA;AACA;AACA;;AACA,IAAMC,eAAe,GAAG,SAAlBA,eAAkB,CAAAC,YAAY,EAAI;AACtCH,EAAAA,aAAa,CAACI,IAAd,CAAmBD,YAAnB;AACD,CAFD;AAIA;AACA;AACA;;;AACA,IAAME,kBAAkB,GAAG,SAArBA,kBAAqB,CAAAF,YAAY,EAAI;AACzC,MAAMG,KAAK,GAAGN,aAAa,CAACO,OAAd,CAAsBJ,YAAtB,CAAd;;AAEA,MAAIG,KAAK,KAAK,CAAC,CAAf,EAAkB;AAChBN,IAAAA,aAAa,CAACQ,MAAd,CAAqBF,KAArB,EAA4B,CAA5B;AACD;AACF,CAND;AAQA;AACA;AACA;;;AACA,IAAMG,SAAS,GAAG,SAAZA,SAAY,OAAwC;AAAA,MAArCC,WAAqC,QAArCA,WAAqC;AAAA,MAAxBC,MAAwB,QAAxBA,MAAwB;AAAA,MAAhBC,SAAgB,QAAhBA,SAAgB;AACxD,MAAMC,GAAG,GAAGC,2BAA2B,CAACJ,WAAD,EAAcC,MAAd,CAAvC;AAEAV,EAAAA,oBAAoB,CAACY,GAAD,CAApB,GAA4BZ,oBAAoB,CAACY,GAAD,CAApB,IAA6B,CAAzD;;AAEA,MAAIZ,oBAAoB,CAACY,GAAD,CAApB,KAA8B,CAAlC,EAAqC;AACnCd,IAAAA,gBAAgB,CAACgB,IAAjB,CAAsBC,IAAI,CAACC,SAAL;AAAiBC,MAAAA,IAAI,EAAE,WAAvB;AAAoCC,MAAAA,MAAM,EAAET;AAA5C,OAA4DC,MAA5D,EAAtB;AACD;;AAEDV,EAAAA,oBAAoB,CAACY,GAAD,CAApB,IAA6B,CAA7B;AACAD,EAAAA,SAAS;AACV,CAXD;AAaA;AACA;AACA;;;AACA,IAAMQ,WAAW,GAAG,SAAdA,WAAc,QAA2C;AAAA,MAAxCV,WAAwC,SAAxCA,WAAwC;AAAA,MAA3BC,MAA2B,SAA3BA,MAA2B;AAAA,MAAnBU,YAAmB,SAAnBA,YAAmB;AAC7D,MAAMR,GAAG,GAAGC,2BAA2B,CAACJ,WAAD,EAAcC,MAAd,CAAvC;AAEAV,EAAAA,oBAAoB,CAACY,GAAD,CAApB,GAA4BZ,oBAAoB,CAACY,GAAD,CAApB,IAA6B,CAAzD;;AAEA,MAAIZ,oBAAoB,CAACY,GAAD,CAApB,KAA8B,CAA9B,IAAmCd,gBAAgB,CAACuB,UAAjB,KAAgCxB,eAAe,CAACyB,IAAvF,EAA6F;AAC3FxB,IAAAA,gBAAgB,CAACgB,IAAjB,CAAsBC,IAAI,CAACC,SAAL;AAAiBC,MAAAA,IAAI,EAAE,aAAvB;AAAsCC,MAAAA,MAAM,EAAET;AAA9C,OAA8DC,MAA9D,EAAtB;AACD;;AAEDV,EAAAA,oBAAoB,CAACY,GAAD,CAApB,IAA6B,CAA7B;AACAQ,EAAAA,YAAY;AACb,CAXD;;AAaA,IAAMG,eAAe,GAAG;AACtBC,EAAAA,SAAS,GAAI;AACXzB,IAAAA,aAAa,CAAC0B,OAAd,CAAsB,UAAAvB,YAAY;AAAA,aAAIM,SAAS,CAACN,YAAD,CAAb;AAAA,KAAlC;AACD,GAHqB;;AAKtBwB,EAAAA,QAAQ,CAAEC,IAAF,EAAQ;AACd,QAAQT,MAAR,GAAmBS,IAAnB,CAAQT,MAAR;AAEAnB,IAAAA,aAAa,CAAC6B,MAAd,CAAqB,iBAA6B;AAAA,UAA1BnB,WAA0B,SAA1BA,WAA0B;AAAA,UAAbC,MAAa,SAAbA,MAAa;AAChD,UAAMmB,iBAAiB,GAAGX,MAAM,CAAC,CAAD,CAAhC;;AAEA,UAAIA,MAAM,CAACY,MAAP,KAAkB,CAAtB,EAAyB;AACvB,eAAOrB,WAAW,KAAKoB,iBAAvB;AACD;;AAED,UAAME,gBAAgB,GAAGb,MAAM,CAAC,CAAD,CAA/B;;AAEA,UAAI,CAAC,SAAD,EAAY,eAAZ,EAA6Bc,QAA7B,CAAsCvB,WAAtC,CAAJ,EAAwD;AACtD,eAAOA,WAAW,KAAKoB,iBAAhB,IAAqCnB,MAAM,CAACuB,GAAP,KAAeF,gBAA3D;AACD,OAFD,MAEO,IAAItB,WAAW,KAAK,MAApB,EAA4B;AACjC,eAAOA,WAAW,KAAKoB,iBAAhB,IAAqCnB,MAAM,CAACwB,IAAP,KAAgBH,gBAA5D;AACD;;AAED,aAAO,KAAP;AACD,KAhBD,EAgBGN,OAhBH,CAgBW,UAAAvB,YAAY,EAAI;AACzBA,MAAAA,YAAY,CAACiC,SAAb,CAAuBR,IAAvB;AACD,KAlBD;AAmBD,GA3BqB;;AA6BtBS,EAAAA,YAAY,GAAI;AACdrC,IAAAA,aAAa,CAAC0B,OAAd,CAAsB,UAAAvB,YAAY;AAAA,aAAIiB,WAAW,CAACjB,YAAD,CAAf;AAAA,KAAlC;AACD,GA/BqB;;AAiCtBmC,EAAAA,WAAW,GAAI,CACd;;AAlCqB,CAAxB;AAqCA;AACA;AACA;AACA;AACA;;AACA,IAAMxB,2BAA2B,GAAG,SAA9BA,2BAA8B,CAACJ,WAAD,EAAcC,MAAd,EAAyB;AAC3D,MAAI4B,MAAM,CAACC,IAAP,CAAY7B,MAAZ,EAAoBoB,MAApB,KAA+B,CAAnC,EAAsC;AACpC,WAAOrB,WAAP;AACD;;AAED,SAAUA,WAAV,SAAyB6B,MAAM,CAACC,IAAP,CAAY7B,MAAZ,EAAoB8B,GAApB,CAAwB,UAAA5B,GAAG;AAAA,WAAOA,GAAP,SAAcF,MAAM,CAACE,GAAD,CAApB;AAAA,GAA3B,EAAwD6B,IAAxD,CAA6D,GAA7D,CAAzB;AACD,CAND;AAQA;AACA;AACA;AACA;AACA;AACA;;;AACA,OAAO,IAAMC,aAAa,GAAG,SAAhBA,aAAgB,CAACjC,WAAD,EAAcC,MAAd,EAAsBiC,SAAtB;AAAA,SAAoC,UAACC,QAAD,EAAWC,QAAX,EAAwB;AACvF,QAAMC,mBAAmB,GAAGD,QAAQ,GAAGE,KAAX,CAAiB,CAAC,MAAD,EAAS,wBAAT,CAAjB,CAA5B;AACA,QAAMC,WAAW,GAAGH,QAAQ,GAAGE,KAAX,CAAiB,CAAC,MAAD,EAAS,cAAT,CAAjB,CAApB;;AACA,qBAA+CJ,SAAS,CAACC,QAAD,EAAWC,QAAX,CAAxD;AAAA,QAAQlC,SAAR,cAAQA,SAAR;AAAA,QAAmBwB,SAAnB,cAAmBA,SAAnB;AAAA,QAA8Bf,YAA9B,cAA8BA,YAA9B,CAHuF,CAKvF;AACA;;;AACA,QAAI,CAAC0B,mBAAmB,CAACG,UAApB,CAA+B,IAA/B,CAAL,EAA2C;AACzC,UAAMC,UAAU,GAAGC,gBAAgB,CAACL,mBAAD,EAAsBE,WAAtB,EAAmCnC,2BAA2B,CAACJ,WAAD,EAAcC,MAAd,CAA9D,EAAqF;AACtHc,QAAAA,SAAS,GAAI;AACXb,UAAAA,SAAS;AACV,SAHqH;;AAKtHe,QAAAA,QAAQ,CAAEC,IAAF,EAAQ;AACdQ,UAAAA,SAAS,CAACR,IAAD,CAAT;AACD,SAPqH;;AAStHS,QAAAA,YAAY,GAAI;AACdhB,UAAAA,YAAY;AACb,SAXqH;;AAatHiB,QAAAA,WAAW,GAAI;AACb1B,UAAAA,SAAS;AACV;;AAfqH,OAArF,CAAnC;AAkBA,aAAO,YAAM;AACXuC,QAAAA,UAAU,CAACE,KAAX;AACD,OAFD;AAGD;;AAED,QAAMlD,YAAY,GAAG;AACnBO,MAAAA,WADmB;AAEnBC,MAAAA,MAFmB;AAGnBC,MAAAA,SAHmB;AAInBwB,MAAAA,SAJmB;AAKnBf,MAAAA;AALmB,KAArB;AAQAnB,IAAAA,eAAe,CAACC,YAAD,CAAf,CAvCuF,CAyCvF;AACA;;AAEA,QAAI,CAACJ,gBAAL,EAAuB;AACrBA,MAAAA,gBAAgB;AAAG;AAAgCqD,MAAAA,gBAAgB,CAACL,mBAAD,EAAsBE,WAAtB,EAAmC,EAAnC,EAAuCzB,eAAvC,CAAnE;AACD,KAFD,MAEO,IAAIzB,gBAAgB,CAACuB,UAAjB,KAAgCxB,eAAe,CAACyB,IAApD,EAA0D;AAC/Dd,MAAAA,SAAS,CAACN,YAAD,CAAT;AACD;;AAED,WAAO,YAAM;AACXE,MAAAA,kBAAkB,CAACF,YAAD,CAAlB;AACAiB,MAAAA,WAAW,CAACjB,YAAD,CAAX;AACD,KAHD;AAID,GAtD4B;AAAA,CAAtB;AAwDP,IAAMmD,iBAAiB,GAAG,CACxB,QADwB,EAExB,QAFwB,EAGxB,cAHwB,EAIxB,cAJwB,EAKxB,iBALwB,EAMxB,mBANwB,EAOxB,cAPwB,EAQxB,qBARwB,EASxB,uBATwB,CAA1B;AAYA;AACA;AACA;AACA;;AACA,IAAMC,wBAAwB,GAAG,SAA3BA,wBAA2B,CAACC,CAAD,EAAI7B,QAAJ,EAAiB;AAChDA,EAAAA,QAAQ,CAAC;AACP8B,IAAAA,KAAK,EAAED,CAAC,CAACtC,IADF;AAEPwC,IAAAA,OAAO,EAAEF,CAAC,CAAC5B;AAFJ,GAAD,CAAR;AAID,CALD;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,IAAMwB,gBAAgB,GAAG,SAAnBA,gBAAmB,CAACL,mBAAD,EAAsBE,WAAtB,EAAmCvC,WAAnC,SAAuG;AAAA,MAArDe,SAAqD,SAArDA,SAAqD;AAAA,MAA1CE,QAA0C,SAA1CA,QAA0C;AAAA,MAAhCU,YAAgC,SAAhCA,YAAgC;AAAA,MAAlBC,WAAkB,SAAlBA,WAAkB;AAC9H,MAAM3B,MAAM,GAAGD,WAAW,CAACiD,KAAZ,CAAkB,GAAlB,CAAf;AAEAjD,EAAAA,WAAW,GAAGC,MAAM,CAACiD,KAAP,EAAd;;AAEA,MAAIb,mBAAmB,CAACG,UAApB,CAA+B,IAA/B,CAAJ,EAA0C;AACxC,QAAMW,EAAE,GAAG,IAAI/D,eAAJ,CAAuBiD,mBAAvB,2BAAgEpC,MAAM,CAAC+B,IAAP,CAAY,GAAZ,CAAhE,EAAoFO,WAApF,CAAX;AAEAY,IAAAA,EAAE,CAACC,MAAH,GAAiBrC,SAAjB;;AACAoC,IAAAA,EAAE,CAACE,SAAH,GAAiB,UAAAP,CAAC;AAAA,aAAI7B,QAAQ,CAACX,IAAI,CAACgD,KAAL,CAAWR,CAAC,CAAC5B,IAAb,CAAD,CAAZ;AAAA,KAAlB;;AACAiC,IAAAA,EAAE,CAACI,OAAH,GAAiB5B,YAAjB;AACAwB,IAAAA,EAAE,CAACK,WAAH,GAAiB5B,WAAjB;AAEA,WAAOuB,EAAP;AACD;;AAEDnD,EAAAA,WAAW,GAAGA,WAAW,CAACyD,OAAZ,CAAoB,IAApB,EAA0B,GAA1B,CAAd;;AAEA,MAAIzD,WAAW,CAAC0D,QAAZ,CAAqB,QAArB,CAAJ,EAAoC;AAClC1D,IAAAA,WAAW,GAAGA,WAAW,CAACyD,OAAZ,CAAoB,QAApB,EAA8B,EAA9B,CAAd;AACAxD,IAAAA,MAAM,CAACP,IAAP,CAAY,iBAAZ;AACD;;AAEDO,EAAAA,MAAM,CAACP,IAAP,mBAA4B6C,WAA5B;AAEA,MAAMoB,EAAE,GAAG,IAAIC,WAAJ,CAAmBvB,mBAAnB,0BAA2DrC,WAA3D,SAA0EC,MAAM,CAAC+B,IAAP,CAAY,GAAZ,CAA1E,CAAX;;AAEA2B,EAAAA,EAAE,CAACP,MAAH,GAAY,YAAM;AAChBrC,IAAAA,SAAS;AACV,GAFD;;AAIA6B,EAAAA,iBAAiB,CAAC5B,OAAlB,CAA0B,UAAAR,IAAI,EAAI;AAChCmD,IAAAA,EAAE,CAACE,gBAAH,CAAoBrD,IAApB,EAA0B,UAAAsC,CAAC;AAAA,aAAID,wBAAwB;AAAC;AAA6BC,MAAAA,CAA9B,EAAkC7B,QAAlC,CAA5B;AAAA,KAA3B;AACD,GAFD;AAIA0C,EAAAA,EAAE,CAACG,OAAH;AAAa;AAAiCnC,EAAAA,YAA9C;AAEA,SAAOgC,EAAP;AACD,CAtCD","sourcesContent":["// @ts-check\n\nimport WebSocketClient from '@gamestdio/websocket';\n\n/**\n * @type {WebSocketClient | undefined}\n */\nlet sharedConnection;\n\n/**\n * @typedef Subscription\n * @property {string} channelName\n * @property {Object.<string, string>} params\n * @property {function(): void} onConnect\n * @property {function(StreamEvent): void} onReceive\n * @property {function(): void} onDisconnect\n */\n\n/**\n  * @typedef StreamEvent\n  * @property {string} event\n  * @property {object} payload\n  */\n\n/**\n * @type {Array.<Subscription>}\n */\nconst subscriptions = [];\n\n/**\n * @type {Object.<string, number>}\n */\nconst subscriptionCounters = {};\n\n/**\n * @param {Subscription} subscription\n */\nconst addSubscription = subscription => {\n  subscriptions.push(subscription);\n};\n\n/**\n * @param {Subscription} subscription\n */\nconst removeSubscription = subscription => {\n  const index = subscriptions.indexOf(subscription);\n\n  if (index !== -1) {\n    subscriptions.splice(index, 1);\n  }\n};\n\n/**\n * @param {Subscription} subscription\n */\nconst subscribe = ({ channelName, params, onConnect }) => {\n  const key = channelNameWithInlineParams(channelName, params);\n\n  subscriptionCounters[key] = subscriptionCounters[key] || 0;\n\n  if (subscriptionCounters[key] === 0) {\n    sharedConnection.send(JSON.stringify({ type: 'subscribe', stream: channelName, ...params }));\n  }\n\n  subscriptionCounters[key] += 1;\n  onConnect();\n};\n\n/**\n * @param {Subscription} subscription\n */\nconst unsubscribe = ({ channelName, params, onDisconnect }) => {\n  const key = channelNameWithInlineParams(channelName, params);\n\n  subscriptionCounters[key] = subscriptionCounters[key] || 1;\n\n  if (subscriptionCounters[key] === 1 && sharedConnection.readyState === WebSocketClient.OPEN) {\n    sharedConnection.send(JSON.stringify({ type: 'unsubscribe', stream: channelName, ...params }));\n  }\n\n  subscriptionCounters[key] -= 1;\n  onDisconnect();\n};\n\nconst sharedCallbacks = {\n  connected () {\n    subscriptions.forEach(subscription => subscribe(subscription));\n  },\n\n  received (data) {\n    const { stream } = data;\n\n    subscriptions.filter(({ channelName, params }) => {\n      const streamChannelName = stream[0];\n\n      if (stream.length === 1) {\n        return channelName === streamChannelName;\n      }\n\n      const streamIdentifier = stream[1];\n\n      if (['hashtag', 'hashtag:local'].includes(channelName)) {\n        return channelName === streamChannelName && params.tag === streamIdentifier;\n      } else if (channelName === 'list') {\n        return channelName === streamChannelName && params.list === streamIdentifier;\n      }\n\n      return false;\n    }).forEach(subscription => {\n      subscription.onReceive(data);\n    });\n  },\n\n  disconnected () {\n    subscriptions.forEach(subscription => unsubscribe(subscription));\n  },\n\n  reconnected () {\n  },\n};\n\n/**\n * @param {string} channelName\n * @param {Object.<string, string>} params\n * @return {string}\n */\nconst channelNameWithInlineParams = (channelName, params) => {\n  if (Object.keys(params).length === 0) {\n    return channelName;\n  }\n\n  return `${channelName}&${Object.keys(params).map(key => `${key}=${params[key]}`).join('&')}`;\n};\n\n/**\n * @param {string} channelName\n * @param {Object.<string, string>} params\n * @param {function(Function, Function): { onConnect: (function(): void), onReceive: (function(StreamEvent): void), onDisconnect: (function(): void) }} callbacks\n * @return {function(): void}\n */\nexport const connectStream = (channelName, params, callbacks) => (dispatch, getState) => {\n  const streamingAPIBaseURL = getState().getIn(['meta', 'streaming_api_base_url']);\n  const accessToken = getState().getIn(['meta', 'access_token']);\n  const { onConnect, onReceive, onDisconnect } = callbacks(dispatch, getState);\n\n  // If we cannot use a websockets connection, we must fall back\n  // to using individual connections for each channel\n  if (!streamingAPIBaseURL.startsWith('ws')) {\n    const connection = createConnection(streamingAPIBaseURL, accessToken, channelNameWithInlineParams(channelName, params), {\n      connected () {\n        onConnect();\n      },\n\n      received (data) {\n        onReceive(data);\n      },\n\n      disconnected () {\n        onDisconnect();\n      },\n\n      reconnected () {\n        onConnect();\n      },\n    });\n\n    return () => {\n      connection.close();\n    };\n  }\n\n  const subscription = {\n    channelName,\n    params,\n    onConnect,\n    onReceive,\n    onDisconnect,\n  };\n\n  addSubscription(subscription);\n\n  // If a connection is open, we can execute the subscription right now. Otherwise,\n  // because we have already registered it, it will be executed on connect\n\n  if (!sharedConnection) {\n    sharedConnection = /** @type {WebSocketClient} */ (createConnection(streamingAPIBaseURL, accessToken, '', sharedCallbacks));\n  } else if (sharedConnection.readyState === WebSocketClient.OPEN) {\n    subscribe(subscription);\n  }\n\n  return () => {\n    removeSubscription(subscription);\n    unsubscribe(subscription);\n  };\n};\n\nconst KNOWN_EVENT_TYPES = [\n  'update',\n  'delete',\n  'notification',\n  'conversation',\n  'filters_changed',\n  'encrypted_message',\n  'announcement',\n  'announcement.delete',\n  'announcement.reaction',\n];\n\n/**\n * @param {MessageEvent} e\n * @param {function(StreamEvent): void} received\n */\nconst handleEventSourceMessage = (e, received) => {\n  received({\n    event: e.type,\n    payload: e.data,\n  });\n};\n\n/**\n * @param {string} streamingAPIBaseURL\n * @param {string} accessToken\n * @param {string} channelName\n * @param {{ connected: Function, received: function(StreamEvent): void, disconnected: Function, reconnected: Function }} callbacks\n * @return {WebSocketClient | EventSource}\n */\nconst createConnection = (streamingAPIBaseURL, accessToken, channelName, { connected, received, disconnected, reconnected }) => {\n  const params = channelName.split('&');\n\n  channelName = params.shift();\n\n  if (streamingAPIBaseURL.startsWith('ws')) {\n    const ws = new WebSocketClient(`${streamingAPIBaseURL}/api/v1/streaming/?${params.join('&')}`, accessToken);\n\n    ws.onopen      = connected;\n    ws.onmessage   = e => received(JSON.parse(e.data));\n    ws.onclose     = disconnected;\n    ws.onreconnect = reconnected;\n\n    return ws;\n  }\n\n  channelName = channelName.replace(/:/g, '/');\n\n  if (channelName.endsWith(':media')) {\n    channelName = channelName.replace('/media', '');\n    params.push('only_media=true');\n  }\n\n  params.push(`access_token=${accessToken}`);\n\n  const es = new EventSource(`${streamingAPIBaseURL}/api/v1/streaming/${channelName}?${params.join('&')}`);\n\n  es.onopen = () => {\n    connected();\n  };\n\n  KNOWN_EVENT_TYPES.forEach(type => {\n    es.addEventListener(type, e => handleEventSourceMessage(/** @type {MessageEvent} */ (e), received));\n  });\n\n  es.onerror = /** @type {function(): void} */ (disconnected);\n\n  return es;\n};\n"]},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module"}