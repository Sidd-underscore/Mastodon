{"ast":null,"code":"import { ACCOUNT_BLOCK_SUCCESS, ACCOUNT_MUTE_SUCCESS } from '../actions/accounts';\nimport { CONTEXT_FETCH_SUCCESS } from '../actions/statuses';\nimport { TIMELINE_DELETE, TIMELINE_UPDATE } from '../actions/timelines';\nimport { Map as ImmutableMap, List as ImmutableList } from 'immutable';\nimport compareId from '../compare_id';\nvar initialState = ImmutableMap({\n  inReplyTos: ImmutableMap(),\n  replies: ImmutableMap()\n});\n\nvar normalizeContext = function normalizeContext(immutableState, id, ancestors, descendants) {\n  return immutableState.withMutations(function (state) {\n    state.update('inReplyTos', function (immutableAncestors) {\n      return immutableAncestors.withMutations(function (inReplyTos) {\n        state.update('replies', function (immutableDescendants) {\n          return immutableDescendants.withMutations(function (replies) {\n            function addReply(_ref) {\n              var id = _ref.id,\n                  in_reply_to_id = _ref.in_reply_to_id;\n\n              if (in_reply_to_id && !inReplyTos.has(id)) {\n                replies.update(in_reply_to_id, ImmutableList(), function (siblings) {\n                  var index = siblings.findLastIndex(function (sibling) {\n                    return compareId(sibling, id) < 0;\n                  });\n                  return siblings.insert(index + 1, id);\n                });\n                inReplyTos.set(id, in_reply_to_id);\n              }\n            } // We know in_reply_to_id of statuses but `id` itself.\n            // So we assume that the status of the id replies to last ancestors.\n\n\n            ancestors.forEach(addReply);\n\n            if (ancestors[0]) {\n              addReply({\n                id,\n                in_reply_to_id: ancestors[ancestors.length - 1].id\n              });\n            }\n\n            descendants.forEach(addReply);\n          });\n        });\n      });\n    });\n  });\n};\n\nvar deleteFromContexts = function deleteFromContexts(immutableState, ids) {\n  return immutableState.withMutations(function (state) {\n    state.update('inReplyTos', function (immutableAncestors) {\n      return immutableAncestors.withMutations(function (inReplyTos) {\n        state.update('replies', function (immutableDescendants) {\n          return immutableDescendants.withMutations(function (replies) {\n            ids.forEach(function (id) {\n              var inReplyToIdOfId = inReplyTos.get(id);\n              var repliesOfId = replies.get(id);\n              var siblings = replies.get(inReplyToIdOfId);\n\n              if (siblings) {\n                replies.set(inReplyToIdOfId, siblings.filterNot(function (sibling) {\n                  return sibling === id;\n                }));\n              }\n\n              if (repliesOfId) {\n                repliesOfId.forEach(function (reply) {\n                  return inReplyTos.delete(reply);\n                });\n              }\n\n              inReplyTos.delete(id);\n              replies.delete(id);\n            });\n          });\n        });\n      });\n    });\n  });\n};\n\nvar filterContexts = function filterContexts(state, relationship, statuses) {\n  var ownedStatusIds = statuses.filter(function (status) {\n    return status.get('account') === relationship.id;\n  }).map(function (status) {\n    return status.get('id');\n  });\n  return deleteFromContexts(state, ownedStatusIds);\n};\n\nvar updateContext = function updateContext(state, status) {\n  if (status.in_reply_to_id) {\n    return state.withMutations(function (mutable) {\n      var replies = mutable.getIn(['replies', status.in_reply_to_id], ImmutableList());\n      mutable.setIn(['inReplyTos', status.id], status.in_reply_to_id);\n\n      if (!replies.includes(status.id)) {\n        mutable.setIn(['replies', status.in_reply_to_id], replies.push(status.id));\n      }\n    });\n  }\n\n  return state;\n};\n\nexport default function replies(state, action) {\n  if (state === void 0) {\n    state = initialState;\n  }\n\n  switch (action.type) {\n    case ACCOUNT_BLOCK_SUCCESS:\n    case ACCOUNT_MUTE_SUCCESS:\n      return filterContexts(state, action.relationship, action.statuses);\n\n    case CONTEXT_FETCH_SUCCESS:\n      return normalizeContext(state, action.id, action.ancestors, action.descendants);\n\n    case TIMELINE_DELETE:\n      return deleteFromContexts(state, [action.id]);\n\n    case TIMELINE_UPDATE:\n      return updateContext(state, action.status);\n\n    default:\n      return state;\n  }\n}\n;","map":{"version":3,"sources":["/home/runner/Mastodon/live/app/javascript/mastodon/reducers/contexts.js"],"names":["ACCOUNT_BLOCK_SUCCESS","ACCOUNT_MUTE_SUCCESS","CONTEXT_FETCH_SUCCESS","TIMELINE_DELETE","TIMELINE_UPDATE","Map","ImmutableMap","List","ImmutableList","compareId","initialState","inReplyTos","replies","normalizeContext","immutableState","id","ancestors","descendants","withMutations","state","update","immutableAncestors","immutableDescendants","addReply","in_reply_to_id","has","siblings","index","findLastIndex","sibling","insert","set","forEach","length","deleteFromContexts","ids","inReplyToIdOfId","get","repliesOfId","filterNot","reply","delete","filterContexts","relationship","statuses","ownedStatusIds","filter","status","map","updateContext","mutable","getIn","setIn","includes","push","action","type"],"mappings":"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","sourcesContent":["import {\n  ACCOUNT_BLOCK_SUCCESS,\n  ACCOUNT_MUTE_SUCCESS,\n} from '../actions/accounts';\nimport { CONTEXT_FETCH_SUCCESS } from '../actions/statuses';\nimport { TIMELINE_DELETE, TIMELINE_UPDATE } from '../actions/timelines';\nimport { Map as ImmutableMap, List as ImmutableList } from 'immutable';\nimport compareId from '../compare_id';\n\nconst initialState = ImmutableMap({\n  inReplyTos: ImmutableMap(),\n  replies: ImmutableMap(),\n});\n\nconst normalizeContext = (immutableState, id, ancestors, descendants) => immutableState.withMutations(state => {\n  state.update('inReplyTos', immutableAncestors => immutableAncestors.withMutations(inReplyTos => {\n    state.update('replies', immutableDescendants => immutableDescendants.withMutations(replies => {\n      function addReply({ id, in_reply_to_id }) {\n        if (in_reply_to_id && !inReplyTos.has(id)) {\n\n          replies.update(in_reply_to_id, ImmutableList(), siblings => {\n            const index = siblings.findLastIndex(sibling => compareId(sibling, id) < 0);\n            return siblings.insert(index + 1, id);\n          });\n\n          inReplyTos.set(id, in_reply_to_id);\n        }\n      }\n\n      // We know in_reply_to_id of statuses but `id` itself.\n      // So we assume that the status of the id replies to last ancestors.\n\n      ancestors.forEach(addReply);\n\n      if (ancestors[0]) {\n        addReply({ id, in_reply_to_id: ancestors[ancestors.length - 1].id });\n      }\n\n      descendants.forEach(addReply);\n    }));\n  }));\n});\n\nconst deleteFromContexts = (immutableState, ids) => immutableState.withMutations(state => {\n  state.update('inReplyTos', immutableAncestors => immutableAncestors.withMutations(inReplyTos => {\n    state.update('replies', immutableDescendants => immutableDescendants.withMutations(replies => {\n      ids.forEach(id => {\n        const inReplyToIdOfId = inReplyTos.get(id);\n        const repliesOfId = replies.get(id);\n        const siblings = replies.get(inReplyToIdOfId);\n\n        if (siblings) {\n          replies.set(inReplyToIdOfId, siblings.filterNot(sibling => sibling === id));\n        }\n\n\n        if (repliesOfId) {\n          repliesOfId.forEach(reply => inReplyTos.delete(reply));\n        }\n\n        inReplyTos.delete(id);\n        replies.delete(id);\n      });\n    }));\n  }));\n});\n\nconst filterContexts = (state, relationship, statuses) => {\n  const ownedStatusIds = statuses\n    .filter(status => status.get('account') === relationship.id)\n    .map(status => status.get('id'));\n\n  return deleteFromContexts(state, ownedStatusIds);\n};\n\nconst updateContext = (state, status) => {\n  if (status.in_reply_to_id) {\n    return state.withMutations(mutable => {\n      const replies = mutable.getIn(['replies', status.in_reply_to_id], ImmutableList());\n\n      mutable.setIn(['inReplyTos', status.id], status.in_reply_to_id);\n\n      if (!replies.includes(status.id)) {\n        mutable.setIn(['replies', status.in_reply_to_id], replies.push(status.id));\n      }\n    });\n  }\n\n  return state;\n};\n\nexport default function replies(state = initialState, action) {\n  switch(action.type) {\n  case ACCOUNT_BLOCK_SUCCESS:\n  case ACCOUNT_MUTE_SUCCESS:\n    return filterContexts(state, action.relationship, action.statuses);\n  case CONTEXT_FETCH_SUCCESS:\n    return normalizeContext(state, action.id, action.ancestors, action.descendants);\n  case TIMELINE_DELETE:\n    return deleteFromContexts(state, [action.id]);\n  case TIMELINE_UPDATE:\n    return updateContext(state, action.status);\n  default:\n    return state;\n  }\n};\n"]},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module"}